/**
 * @fileoverview ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¯ãƒ©ã‚¹ - Markdown Viewerã®ãƒ¡ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ãƒãƒ¼æ©Ÿèƒ½ã‚’æä¾›
 *
 * ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ã€Chromeæ‹¡å¼µæ©Ÿèƒ½ã€ŒMarkdown Viewer with Mermaidã€ã®ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ç®¡ç†ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
 * æ¤œç´¢ã€ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆã€å°åˆ·ã€ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã€è¨­å®šãªã©ã®æ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
 *
 * @author 76Hata
 * @version 2.0.0
 * @since 1.0.0
 */

/**
 * ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¯ãƒ©ã‚¹
 * Markdownãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ã®ãƒ¡ã‚¤ãƒ³ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½œæˆãƒ»ç®¡ç†ã—ã¾ã™
 *
 * @class Toolbar
 * @description ã“ã®ã‚¯ãƒ©ã‚¹ã¯ä»¥ä¸‹ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ï¼š
 * - ãƒ•ãƒ­ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ä½œæˆã¨é…ç½®
 * - æ¤œç´¢æ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
 * - ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆæ©Ÿèƒ½
 * - å°åˆ·æ©Ÿèƒ½
 * - ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆHTMLï¼‰
 * - è¨­å®šãƒ‘ãƒãƒ«ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
 * - ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ãƒ‰ãƒ©ãƒƒã‚°ç§»å‹•
 * - ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
 *
 * @example
 * // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’åˆæœŸåŒ–
 * const toolbar = new Toolbar(document.body);
 *
 * // ç‰¹å®šã®ã‚³ãƒ³ãƒ†ãƒŠã«ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’ä½œæˆ
 * const toolbar = new Toolbar(document.getElementById('content'));
 *
 * @author 76Hata
 * @since 1.0.0
 */
class Toolbar {
  /**
   * Toolbarã‚¯ãƒ©ã‚¹ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
   *
   * @constructor
   * @param {Element} container - ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’é…ç½®ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠè¦ç´ 
   * @description ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’åˆæœŸåŒ–ã—ã¾ã™ã€‚
   *              å„ç¨®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¨­å®šã—ã€init()ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚
   * @since 1.0.0
   */
  constructor(container) {
    /** @type {Element} ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’é…ç½®ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒŠè¦ç´  */
    this.container = container || document.body;

    /** @type {HTMLElement|null} ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®DOMè¦ç´  */
    this.toolbarElement = null;

    /** @type {ThemeManager|null} ãƒ†ãƒ¼ãƒç®¡ç†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ */
    this.themeManager = null;

    /** @type {SearchEngine|null} æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ */
    this.searchEngine = null;

    /** @type {TOCGenerator|null} ç›®æ¬¡ç”Ÿæˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ */
    this.tocGenerator = null;

    this.init();
  }

  /**
   * ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®åˆæœŸåŒ–å‡¦ç†
   *
   * @method init
   * @description ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚ä»¥ä¸‹ã®é †åºã§å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ï¼š
   *              1. ã‚³ãƒ³ãƒ†ãƒŠè¦ç´ ã®å­˜åœ¨ç¢ºèª
   *              2. ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¦ç´ ã®ä½œæˆ
   *              3. ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
   *              4. é–¢é€£ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®åˆæœŸåŒ–
   * @returns {void} æˆ»ã‚Šå€¤ãªã—
   * @since 1.0.0
   */
  init() {
    // DOMè¦ç´ ã®å­˜åœ¨ç¢ºèª
    if (!this.container) {
      console.error('Toolbar container not found');
      return;
    }

    this.createToolbar();
    this.bindEvents();
    this.initializeComponents();
  }

  createToolbar() {
    this.toolbarElement = document.createElement('div');
    this.toolbarElement.className = 'main-toolbar';
    this.toolbarElement.title = 'ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•å¯èƒ½';
    this.toolbarElement.innerHTML = `
            <div class="toolbar-drag-handle" title="ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ç§»å‹•">â‹®â‹®</div>
            <button class="toolbar-btn" id="search-btn" title="æ¤œç´¢ (Ctrl+F)">
                ğŸ”
            </button>
            <div class="theme-selector-container"></div>
            <button class="toolbar-btn" id="print-btn" title="å°åˆ· (Ctrl+Shift+P)">
                ğŸ–¨ï¸
            </button>
            <div class="export-selector">
                <button class="toolbar-btn export-selector-button" title="ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ">
                    ğŸ“¤
                </button>
                <div class="export-dropdown" style="display: none;">
                    <div class="export-options">
                        <div class="export-option" data-type="html">
                            <div class="export-preview">ğŸ“„</div>
                            <span class="export-option-label">HTML</span>
                        </div>
                    </div>
                </div>
            </div>
            <button class="toolbar-btn" id="settings-btn" title="è¨­å®š">
                âš™ï¸
            </button>
            <button class="toolbar-btn" id="hide-toolbar-btn" title="ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš ã™ (F11)">
                âœ•
            </button>
        `;

    this.container.appendChild(this.toolbarElement);
    this.createShowButton();
    this.makeDraggable(this.toolbarElement);
    this.restoreToolbarPosition();
  }

  initializeComponents() {
    try {
      // Theme Manager
      if (typeof ThemeManager !== 'undefined') {
        this.themeManager = new ThemeManager();
      } else {
        console.warn('ThemeManager not available');
      }

      // Theme Selector
      const themeContainer = this.toolbarElement?.querySelector(
        '.theme-selector-container'
      );
      if (themeContainer) {
        this.createThemeSelector(themeContainer);
        // ãƒ†ãƒ¼ãƒã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ä½œæˆå¾Œã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒã‚¤ãƒ³ãƒ‰
        setTimeout(() => {
          this.bindThemeEvents();
        }, 50);
      }

      // Search Engine (using fixed version)
      if (typeof SearchEngine !== 'undefined') {
        this.searchEngine = new SearchEngine();
      } else {
        console.warn('SearchEngine not available');
      }

      // TOC Generator (if headings exist)
      setTimeout(() => {
        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
        console.log(`Found ${headings.length} headings for TOC`);

        if (headings.length > 0 && typeof TOCGenerator !== 'undefined') {
          try {
            this.tocGenerator = new TOCGenerator();
            console.log('âœ… TOC Generator initialized');
          } catch (error) {
            console.error('âŒ TOC Generator initialization failed:', error);
          }
        } else {
          console.warn(
            'TOC Generator disabled: no headings or class not available'
          );
        }
      }, 100);
    } catch (error) {
      console.error('Error initializing components:', error);
    }
  }

  createThemeSelector(container) {
    const themeSelector = document.createElement('div');
    themeSelector.className = 'theme-selector';
    themeSelector.innerHTML = `
            <button class="toolbar-btn theme-selector-button" title="ãƒ†ãƒ¼ãƒã‚’é¸æŠ">
                ğŸ¨ <span class="theme-name">Light</span>
            </button>
            <div class="theme-dropdown" style="display: none;">
                <div class="theme-options">
                    <div class="theme-option" data-theme="light">
                        <div class="theme-preview light-preview">
                            <div class="preview-text">Aa</div>
                        </div>
                        <span class="theme-label">Light</span>
                    </div>
                    <div class="theme-option" data-theme="dark">
                        <div class="theme-preview dark-preview">
                            <div class="preview-text">Aa</div>
                        </div>
                        <span class="theme-label">Dark</span>
                    </div>
                    <div class="theme-option" data-theme="sepia">
                        <div class="theme-preview sepia-preview">
                            <div class="preview-text">Aa</div>
                        </div>
                        <span class="theme-label">Sepia</span>
                    </div>
                </div>
            </div>
        `;

    container.appendChild(themeSelector);
  }

  /**
   * ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’ãƒã‚¤ãƒ³ãƒ‰
   *
   * @method bindEvents
   * @description ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å„ãƒœã‚¿ãƒ³ãŠã‚ˆã³ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¨­å®šã—ã¾ã™ï¼š
   * - æ¤œç´¢ãƒœã‚¿ãƒ³: æ¤œç´¢ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
   * - å°åˆ·ãƒœã‚¿ãƒ³: å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
   * - ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼: å½¢å¼é¸æŠã¨ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Ÿè¡Œ
   * - è¨­å®šãƒœã‚¿ãƒ³: è¨­å®šãƒ‘ãƒãƒ«ã‚’é–‹ã
   * - éè¡¨ç¤ºãƒœã‚¿ãƒ³: ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’éš ã™
   * - ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ: å„ç¨®æ“ä½œã®é«˜é€Ÿå®Ÿè¡Œ
   *
   * @example
   * // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ãƒã‚¤ãƒ³ãƒ‰ä¾‹
   * this.bindEvents();
   *
   * // è¨­å®šã•ã‚Œã‚‹ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼š
   * // - Ctrl/Cmd + Shift + P â†’ å°åˆ·å®Ÿè¡Œ
   * // - Ctrl/Cmd + T â†’ ç›®æ¬¡ãƒˆã‚°ãƒ«
   * // - F11 â†’ ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¡¨ç¤º/éè¡¨ç¤º
   * // - Escape â†’ ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¡¨ç¤ºï¼ˆéè¡¨ç¤ºæ™‚ã®ã¿ï¼‰
   *
   * @since 1.0.0
   */
  bindEvents() {
    // æ¤œç´¢ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    const searchBtn = this.toolbarElement.querySelector('#search-btn');
    if (searchBtn) {
      searchBtn.addEventListener('click', () => {
        console.log('Search button clicked');
        if (this.searchEngine) {
          this.searchEngine.show();
        } else {
          console.warn('Search Engine not available');
        }
      });
    }

    // å°åˆ·ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    const printBtn = this.toolbarElement.querySelector('#print-btn');
    printBtn.addEventListener('click', () => {
      this.handlePrint();
    });

    // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
    const exportSelector =
      this.toolbarElement.querySelector('.export-selector');
    if (exportSelector) {
      this.bindExportEvents(exportSelector);
    }

    // è¨­å®šãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    const settingsBtn = this.toolbarElement.querySelector('#settings-btn');
    settingsBtn.addEventListener('click', () => {
      this.openSettings();
    });

    // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼éè¡¨ç¤ºãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    const hideBtn = this.toolbarElement.querySelector('#hide-toolbar-btn');
    hideBtn.addEventListener('click', () => {
      this.hideToolbar();
    });

    // ãƒ†ãƒ¼ãƒã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆã¯ä½œæˆå¾Œã«åˆ¥é€”ãƒã‚¤ãƒ³ãƒ‰ã•ã‚Œã¾ã™

    // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆå…¨ä½“ã®ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆãƒãƒ³ãƒ‰ãƒ©ãƒ¼
    document.addEventListener('keydown', e => {
      // Ctrl/Cmd + Shift ã®çµ„ã¿åˆã‚ã›ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
      if ((e.ctrlKey || e.metaKey) && e.shiftKey) {
        switch (e.key) {
          case 'P': // Ctrl+Shift+P: å°åˆ·å®Ÿè¡Œ
            e.preventDefault();
            this.handlePrint();
            break;
        }
      } else if (e.ctrlKey || e.metaKey) {
        // Ctrl/Cmd ã®å˜ä½“ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        switch (e.key) {
          case 't': // Ctrl+T: ç›®æ¬¡ãƒˆã‚°ãƒ«
            e.preventDefault();
            this.toggleTOC();
            break;
        }
      } else if (e.key === 'F11') {
        // F11: ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¡¨ç¤º/éè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        e.preventDefault();
        this.toggleToolbar();
      } else if (e.key === 'Escape' && this.isToolbarHidden()) {
        // Escape: ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¡¨ç¤ºï¼ˆéè¡¨ç¤ºæ™‚ã®ã¿æœ‰åŠ¹ï¼‰
        e.preventDefault();
        this.showToolbar();
      }
    });
  }

  bindThemeEvents() {
    const themeSelector = this.toolbarElement.querySelector('.theme-selector');
    if (!themeSelector) {
      console.warn('Theme selector not found');
      return;
    }

    const button = themeSelector.querySelector('.theme-selector-button');
    const dropdown = themeSelector.querySelector('.theme-dropdown');

    if (!button || !dropdown) {
      console.warn('Theme selector components not found');
      return;
    }

    button.addEventListener('click', e => {
      e.stopPropagation();
      this.toggleThemeDropdown();
    });

    dropdown.addEventListener('click', e => {
      if (e.target.closest('.theme-option')) {
        const themeKey = e.target.closest('.theme-option').dataset.theme;
        this.selectTheme(themeKey);
      }

      // è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã‚’å‰Šé™¤
    });

    document.addEventListener('click', e => {
      if (!themeSelector.contains(e.target)) {
        this.closeThemeDropdown();
      }
    });

    // Theme change observer
    this.themeManager.addObserver((event, data) => {
      if (event === 'themeChanged') {
        this.updateThemeDisplay(data.theme);
      }
    });
  }

  toggleThemeDropdown() {
    const dropdown = this.toolbarElement.querySelector('.theme-dropdown');
    const isVisible = dropdown.style.display !== 'none';
    dropdown.style.display = isVisible ? 'none' : 'block';
  }

  closeThemeDropdown() {
    const dropdown = this.toolbarElement.querySelector('.theme-dropdown');
    dropdown.style.display = 'none';
  }

  async selectTheme(themeKey) {
    if (this.themeManager) {
      await this.themeManager.applyTheme(themeKey);
      this.closeThemeDropdown();
    }
  }

  // toggleAutoThemeé–¢æ•°ã‚’å‰Šé™¤

  updateThemeDisplay(themeName) {
    const themeNameElement = this.toolbarElement.querySelector('.theme-name');
    const themeNames = {
      light: 'Light',
      dark: 'Dark',
      sepia: 'Sepia',
    };

    themeNameElement.textContent = themeNames[themeName] || themeName;

    // Update active state
    this.toolbarElement.querySelectorAll('.theme-option').forEach(option => {
      option.classList.toggle('active', option.dataset.theme === themeName);
    });

    // è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®æ›´æ–°ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤
  }

  bindExportEvents(exportSelector) {
    const button = exportSelector.querySelector('.export-selector-button');
    const dropdown = exportSelector.querySelector('.export-dropdown');

    if (!button || !dropdown) {
      console.warn('Export selector components not found');
      return;
    }

    button.addEventListener('click', e => {
      e.stopPropagation();
      this.toggleExportDropdown();
    });

    dropdown.addEventListener('click', e => {
      if (e.target.closest('.export-option')) {
        const exportType = e.target.closest('.export-option').dataset.type;
        this.handleExportSelection(exportType);
      }
    });

    document.addEventListener('click', e => {
      if (!exportSelector.contains(e.target)) {
        this.closeExportDropdown();
      }
    });
  }

  toggleExportDropdown() {
    const dropdown = this.toolbarElement.querySelector('.export-dropdown');
    const isVisible = dropdown.style.display !== 'none';
    dropdown.style.display = isVisible ? 'none' : 'block';
  }

  closeExportDropdown() {
    const dropdown = this.toolbarElement.querySelector('.export-dropdown');
    dropdown.style.display = 'none';
  }

  handleExportSelection(exportType) {
    console.log('Export type selected:', exportType);

    switch (exportType) {
      case 'html':
        this.exportAsHTML();
        break;
      default:
        console.warn('Unknown export type:', exportType);
    }

    this.closeExportDropdown();
  }

  toggleTOC() {
    if (!this.tocGenerator) {
      return;
    }

    const tocPanel = document.querySelector('.toc-panel');
    if (tocPanel) {
      const isVisible = tocPanel.style.display !== 'none';
      tocPanel.style.display = isVisible ? 'none' : 'block';

      // Update content margin
      const content =
        document.querySelector('#markdown-content') || document.body;
      if (isVisible) {
        content.style.marginLeft = '';
      } else {
        content.style.marginLeft = 'calc(250px + 20px)';
      }
    }
  }

  handlePrint() {
    // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã®æ¤œå‡º
    const isSandboxed = this.detectSandboxEnvironment();

    if (isSandboxed) {
      // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã§ã¯ç›´æ¥ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
      console.log('Print blocked in sandbox environment');
      this.showPrintErrorToast();
      return;
    }

    try {
      window.print();
      console.log('Print dialog opened');

      // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ç›£è¦–ï¼ˆçŸ­æ™‚é–“ï¼‰
      this.monitorPrintErrors();
    } catch (error) {
      console.error('Print failed:', error);
      this.showPrintErrorToast();
    }
  }

  safePrint() {
    // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã®æ¤œå‡º
    const isSandboxed = this.detectSandboxEnvironment();

    if (isSandboxed) {
      // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã§ã¯ç›´æ¥ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
      this.showPrintErrorToast();
      return;
    }

    try {
      // é€šå¸¸ç’°å¢ƒã§ã¯å°åˆ·ã‚’è©¦è¡Œ
      window.print();

      // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ç›£è¦–ï¼ˆçŸ­æ™‚é–“ï¼‰
      this.monitorPrintErrors();
    } catch (error) {
      console.warn('Print function error:', error);
      this.showPrintErrorToast();
    }
  }

  detectSandboxEnvironment() {
    // æ—¢çŸ¥ã®ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã‚’ãƒã‚§ãƒƒã‚¯
    return (
      location.hostname.includes('raw.githubusercontent.com') ||
      location.hostname.includes('githubusercontent.com') ||
      document.documentElement.hasAttribute('sandbox') ||
      (window.parent !== window &&
        window.parent.location.hostname !== location.hostname)
    );
  }

  monitorPrintErrors() {
    const originalConsoleError = console.error;
    let errorDetected = false;

    // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚¨ãƒ©ãƒ¼ã‚’ä¸€æ™‚çš„ã«ç›£è¦–
    console.error = (...args) => {
      const errorMessage = args.join(' ');
      if (
        errorMessage.includes('print') ||
        errorMessage.includes('sandboxed') ||
        errorMessage.includes('allow-modals') ||
        errorMessage.includes('Blocked') ||
        errorMessage.includes('Ignored call')
      ) {
        errorDetected = true;
      }
      originalConsoleError.apply(console, args);
    };

    // 500mså¾Œã«ãƒã‚§ãƒƒã‚¯
    setTimeout(() => {
      console.error = originalConsoleError;
      if (errorDetected) {
        this.showPrintErrorToast();
      }
    }, 500);
  }

  downloadPrintableVersion() {
    const printContent = document.getElementById('markdown-content').innerHTML;
    const currentTitle = document.title || 'markdown-document';
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');

    const htmlContent = `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Print - ${currentTitle}</title>
    <style>
        body { 
            font-family: -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1, h2, h3, h4, h5, h6 { 
            margin-top: 1.5em; 
            margin-bottom: 0.5em; 
            font-weight: 600;
        }
        h1 { font-size: 2em; border-bottom: 2px solid #eee; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code { 
            background: #f6f8fa; 
            padding: 2px 4px; 
            border-radius: 3px; 
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 85%;
        }
        pre { 
            background: #f6f8fa; 
            padding: 16px; 
            border-radius: 6px; 
            overflow-x: auto;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 85%;
        }
        pre code {
            background: transparent;
            padding: 0;
        }
        blockquote {
            border-left: 4px solid #dfe2e5;
            margin: 0;
            padding-left: 16px;
            color: #6a737d;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }
        th, td {
            border: 1px solid #dfe2e5;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f6f8fa;
            font-weight: 600;
        }
        ul, ol {
            padding-left: 2em;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        @media print {
            body { 
                font-size: 12pt; 
                line-height: 1.4;
            }
            h1 { font-size: 18pt; }
            h2 { font-size: 16pt; }
            h3 { font-size: 14pt; }
            h4 { font-size: 13pt; }
            h5, h6 { font-size: 12pt; }
            pre, code {
                font-size: 10pt;
            }
        }
        .print-header {
            text-align: center;
            margin-bottom: 2em;
            padding-bottom: 1em;
            border-bottom: 2px solid #eee;
        }
        .print-footer {
            margin-top: 3em;
            padding-top: 1em;
            border-top: 1px solid #eee;
            text-align: center;
            font-size: 0.9em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="print-header">
        <h1>Markdown Document</h1>
        <p>Generated on ${new Date().toLocaleString()}</p>
        <p>Source: ${location.href}</p>
    </div>
    
    ${printContent}
    
    <div class="print-footer">
        <p>Generated by Markdown Viewer with Mermaid Extension</p>
    </div>
</body>
</html>`;

    // Create blob and download
    const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    // Create download link
    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = `markdown-document-${timestamp}.html`;
    downloadLink.style.display = 'none';

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    // Clean up
    setTimeout(() => URL.revokeObjectURL(url), TIMEOUTS.VERY_LONG_DELAY);

    // Show success message
    this.showDownloadSuccess();
  }

  showDownloadSuccess() {
    const message = document.createElement('div');
    message.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #4caf50;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-size: 14px;
            max-width: 350px;
        `;
    message.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 18px; margin-right: 10px;">âœ…</span>
                <div>
                    <strong>ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼</strong><br>
                    <small>HTMLãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦å°åˆ·ã§ãã¾ã™ã€‚</small>
                </div>
            </div>
        `;
    document.body.appendChild(message);

    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (message.parentNode) {
        message.parentNode.removeChild(message);
      }
    }, 5000);
  }

  showPrintFallback() {
    const message = document.createElement('div');
    message.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #ccc;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            z-index: 10000;
            text-align: center;
            max-width: 400px;
        `;
    message.innerHTML = `
            <h3>å°åˆ·æ©Ÿèƒ½ã«ã¤ã„ã¦</h3>
            <p>ã“ã®ç’°å¢ƒã§ã¯å°åˆ·æ©Ÿèƒ½ãŒåˆ¶é™ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
            <p>ä»¥ä¸‹ã®æ–¹æ³•ã‚’ãŠè©¦ã—ãã ã•ã„ï¼š</p>
            <ul style="text-align: left;">
                <li>ãƒ–ãƒ©ã‚¦ã‚¶ã®å°åˆ·æ©Ÿèƒ½ã‚’ä½¿ç”¨</li>
                <li>ãƒšãƒ¼ã‚¸ã‚’åˆ¥ã®ã‚¿ãƒ–ã§é–‹ã„ã¦ã‹ã‚‰å°åˆ·</li>
                <li>ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ã‚³ãƒ”ãƒ¼&ãƒšãƒ¼ã‚¹ãƒˆã—ã¦å°åˆ·</li>
            </ul>
            <button class="fallback-close-btn" style="
                background: #2196f3; 
                color: white; 
                border: none; 
                padding: 10px 20px; 
                border-radius: 5px; 
                cursor: pointer;
                margin-top: 10px;
            ">é–‰ã˜ã‚‹</button>
        `;
    document.body.appendChild(message);

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
    const fallbackCloseBtn = message.querySelector('.fallback-close-btn');
    if (fallbackCloseBtn) {
      fallbackCloseBtn.addEventListener('click', () => {
        message.remove();
      });
    }

    // Auto-hide after 10 seconds
    setTimeout(() => {
      if (message.parentNode) {
        message.parentNode.removeChild(message);
      }
    }, 10000);
  }

  showPrintErrorToast() {
    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
    const existingToast = document.querySelector('.print-error-toast');
    if (existingToast) {
      existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.className = 'print-error-toast';
    toast.innerHTML = `
            <div class="toast-content">
                <div class="toast-icon">âš ï¸</div>
                <div class="toast-message">
                    <strong>å°åˆ·æ©Ÿèƒ½ã«ã¤ã„ã¦</strong><br>
                    ã“ã®ç”»é¢ã¯ã“ã®ãƒœã‚¿ãƒ³ã§ã¯å°åˆ·ã§ãã¾ã›ã‚“ã€‚<br>
                    ãƒ–ãƒ©ã‚¦ã‚¶ã®å°åˆ·æ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
                </div>
                <button class="toast-close">Ã—</button>
            </div>
        `;

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
    toast.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            max-width: 350px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            animation: slideInRight 0.3s ease;
        `;

    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const content = toast.querySelector('.toast-content');
    content.style.cssText = `
            display: flex;
            align-items: flex-start;
            padding: 16px;
            gap: 12px;
        `;

    // ã‚¢ã‚¤ã‚³ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const icon = toast.querySelector('.toast-icon');
    icon.style.cssText = `
            font-size: 20px;
            flex-shrink: 0;
        `;

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const message = toast.querySelector('.toast-message');
    message.style.cssText = `
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            color: #856404;
        `;

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const closeBtn = toast.querySelector('.toast-close');
    closeBtn.style.cssText = `
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #856404;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            flex-shrink: 0;
        `;

    // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
    if (!document.querySelector('#toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                .toast-close:hover {
                    background: rgba(0,0,0,0.1) !important;
                }
            `;
      document.head.appendChild(style);
    }

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ 
    closeBtn.addEventListener('click', () => {
      toast.remove();
    });

    document.body.appendChild(toast);

    // 8ç§’å¾Œã«è‡ªå‹•ã§æ¶ˆã™
    setTimeout(() => {
      if (toast.parentElement) {
        toast.style.animation = 'slideInRight 0.3s ease reverse';
        setTimeout(() => {
          toast.remove();
        }, 300);
      }
    }, 8000);
  }

  addPrintStyles() {
    const printStyles = `
            @media print {
                .main-toolbar,
                .toc-panel,
                .search-panel {
                    display: none !important;
                }
                
                body {
                    margin: 0 !important;
                    padding: 20px !important;
                    font-size: 12pt !important;
                    line-height: 1.4 !important;
                }
                
                h1, h2, h3, h4, h5, h6 {
                    page-break-after: avoid;
                }
                
                pre, blockquote {
                    page-break-inside: avoid;
                }
                
                .mermaid {
                    page-break-inside: avoid;
                    max-width: 100% !important;
                }
                
                a {
                    text-decoration: none !important;
                    color: inherit !important;
                }
                
                a[href^="http"]:after {
                    content: " (" attr(href) ")";
                    font-size: 10pt;
                    color: #666;
                }
            }
        `;

    const existingPrintStyle = document.getElementById('print-styles');
    if (!existingPrintStyle) {
      const style = document.createElement('style');
      style.id = 'print-styles';
      style.textContent = printStyles;
      document.head.appendChild(style);
    }
  }

  openSettings() {
    // Create settings modal
    const modal = this.createSettingsModal();
    document.body.appendChild(modal);
  }

  createSettingsModal() {
    const modal = document.createElement('div');
    modal.className = 'settings-modal';
    modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>è¨­å®š</h3>
                        <button class="modal-close">Ã—</button>
                    </div>
                    <div class="modal-body">
                        <div class="settings-section">
                            <h4>æ¤œç´¢è¨­å®š</h4>
                            <div class="setting-item">
                                <label>ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²:</label>
                                <div class="color-selection-grid">
                                    <div class="color-option" data-color="#ffff00" style="background-color: #ffff00;" title="é»„è‰²ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰"></div>
                                    <div class="color-option" data-color="#ff0000" style="background-color: #ff0000;" title="èµ¤è‰²"></div>
                                    <div class="color-option" data-color="#00ff00" style="background-color: #00ff00;" title="ç·‘è‰²"></div>
                                    <div class="color-option" data-color="#0000ff" style="background-color: #0000ff;" title="é’è‰²"></div>
                                    <div class="color-option" data-color="#ff00ff" style="background-color: #ff00ff;" title="ãƒã‚¼ãƒ³ã‚¿"></div>
                                    <div class="color-option" data-color="#00ffff" style="background-color: #00ffff;" title="ã‚·ã‚¢ãƒ³"></div>
                                    <div class="color-option" data-color="#ffa500" style="background-color: #ffa500;" title="ã‚ªãƒ¬ãƒ³ã‚¸"></div>
                                    <div class="color-option" data-color="#800080" style="background-color: #800080;" title="ç´«è‰²"></div>
                                </div>
                                <input type="hidden" id="setting-highlight-color" value="#ffff00">
                            </div>
                        </div>
                        
                        <div class="settings-section">
                            <h4>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</h4>
                            <div class="setting-item">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <tr><td>F11</td><td>ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è¡¨ç¤º/éè¡¨ç¤º</td></tr>
                                    <tr><td>Ctrl+F</td><td>æ¤œç´¢ãƒ‘ãƒãƒ«è¡¨ç¤º</td></tr>
                                    <tr><td>Ctrl+T</td><td>ç›®æ¬¡è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ</td></tr>
                                    <tr><td>Ctrl+Shift+P</td><td>å°åˆ·</td></tr>
                                    <tr><td>Esc</td><td>ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹</td></tr>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        `;

    // Color selection events with immediate application
    modal.querySelectorAll('.color-option').forEach(option => {
      option.addEventListener('click', () => {
        // Remove previous selection
        modal
          .querySelectorAll('.color-option')
          .forEach(opt => opt.classList.remove('selected'));
        // Select current option
        option.classList.add('selected');
        // Update hidden input
        const hiddenInput = modal.querySelector('#setting-highlight-color');
        hiddenInput.value = option.dataset.color;

        // Apply immediately
        this.applyHighlightColor(option.dataset.color);
      });
    });

    // Set initial selection
    const defaultColor = '#ffff00';
    const defaultOption = modal.querySelector(`[data-color="${defaultColor}"]`);
    if (defaultOption) {
      defaultOption.classList.add('selected');
    }

    // Modal events
    modal.addEventListener('click', e => {
      if (
        e.target.classList.contains('modal-overlay') ||
        e.target.classList.contains('modal-close')
      ) {
        modal.remove();
      }
    });

    return modal;
  }

  applyHighlightColor(color) {
    // Remove existing highlight style
    const existingStyle = document.getElementById('custom-highlight-style');
    if (existingStyle) {
      existingStyle.remove();
    }

    // Apply new highlight style
    const style = document.createElement('style');
    style.id = 'custom-highlight-style';
    style.textContent = `.search-highlight { background-color: ${color} !important; }`;
    document.head.appendChild(style);

    console.log('Highlight color applied:', color);
  }

  disableTOCButton() {
    const tocBtn = this.toolbarElement?.querySelector('#toggle-toc-btn');
    if (tocBtn) {
      tocBtn.disabled = true;
      tocBtn.style.opacity = '0.5';
      tocBtn.title = 'ç›®æ¬¡ç”Ÿæˆä¸å¯ï¼ˆè¦‹å‡ºã—ãŒã‚ã‚Šã¾ã›ã‚“ï¼‰';
    }
  }

  createShowButton() {
    this.showButtonElement = document.createElement('button');
    this.showButtonElement.className = 'toolbar-show-btn';
    this.showButtonElement.innerHTML = 'ğŸ“‹';
    this.showButtonElement.title =
      'ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¡¨ç¤º (F11 ã¾ãŸã¯ Esc) - ãƒ‰ãƒ©ãƒƒã‚°ã§ç§»å‹•å¯èƒ½';
    this.showButtonElement.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: var(--toolbar-bg);
            border: 1px solid var(--toolbar-border);
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1002;
            box-shadow: 0 4px 12px var(--shadow);
            cursor: move;
            font-size: 18px;
            user-select: none;
        `;

    this.showButtonElement.addEventListener('click', _e => {
      // ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã§ãªã„å ´åˆã®ã¿ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚’è¡¨ç¤º
      if (!this.isDragging) {
        this.showToolbar();
      }
    });

    this.makeDraggable(this.showButtonElement);
    this.container.appendChild(this.showButtonElement);
  }

  makeDraggable(element) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;
    const isToolbar = element === this.toolbarElement;

    // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å ´åˆã¯ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ«ã¾ãŸã¯ãƒ„ãƒ¼ãƒ«ãƒãƒ¼è‡ªä½“ã§ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
    const dragTrigger = isToolbar ? element : element;

    dragTrigger.addEventListener('mousedown', e => {
      // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å ´åˆã€ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–
      if (
        isToolbar &&
        (e.target.tagName === 'BUTTON' || e.target.closest('button'))
      ) {
        return;
      }

      e.preventDefault();
      isDragging = false;
      startX = e.clientX;
      startY = e.clientY;

      const rect = element.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    });

    const handleMouseMove = e => {
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      // 5pxä»¥ä¸Šç§»å‹•ã—ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°ã¨ã¿ãªã™
      if (!isDragging && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
        isDragging = true;
        this.isDragging = true;
      }

      if (isDragging) {
        const elementWidth = element.offsetWidth;
        const elementHeight = element.offsetHeight;
        const newLeft = Math.max(
          0,
          Math.min(window.innerWidth - elementWidth, startLeft + deltaX)
        );
        const newTop = Math.max(
          0,
          Math.min(window.innerHeight - elementHeight, startTop + deltaY)
        );

        element.style.left = `${newLeft}px`;
        element.style.top = `${newTop}px`;
        element.style.right = 'auto';

        // ä½ç½®ã‚’ä¿å­˜
        if (isToolbar) {
          this.saveToolbarPosition(newLeft, newTop);
        }
      }
    };

    const handleMouseUp = () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);

      // ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†å¾Œã€å°‘ã—é…ã‚‰ã›ã¦ã‚¯ãƒªãƒƒã‚¯ãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢
      setTimeout(() => {
        this.isDragging = false;
      }, 100);
    };
  }

  saveToolbarPosition(left, top) {
    if (window.SafeStorage) {
      window.SafeStorage.setItem(
        'toolbar-position',
        JSON.stringify({ left, top })
      );
    }
  }

  restoreToolbarPosition() {
    if (window.SafeStorage) {
      window.SafeStorage.getItem('toolbar-position', saved => {
        this.applyToolbarPosition(saved);
      });
    } else {
      this.applyToolbarPosition(null);
    }
  }

  applyToolbarPosition(saved) {
    if (saved) {
      try {
        const { left, top } = JSON.parse(saved);
        this.toolbarElement.style.left = `${left}px`;
        this.toolbarElement.style.top = `${top}px`;
        this.toolbarElement.style.right = 'auto';
      } catch (e) {
        console.warn('Failed to restore toolbar position:', e);
      }
    }
  }

  hideToolbar() {
    // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ä½ç½®ã‚’è¡¨ç¤ºãƒœã‚¿ãƒ³ã«åæ˜ ï¼ˆå³ç«¯ã«åˆã‚ã›ã‚‹ï¼‰
    const _toolbarRect = this.toolbarElement.getBoundingClientRect();
    const showButtonWidth = 50; // è¡¨ç¤ºãƒœã‚¿ãƒ³ã®å¹…

    if (this.toolbarElement.style.left && this.toolbarElement.style.top) {
      // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å³ç«¯ã‹ã‚‰è¡¨ç¤ºãƒœã‚¿ãƒ³ã®å¹…ã‚’å¼•ã„ã¦ä½ç½®èª¿æ•´
      const toolbarLeft = parseInt(this.toolbarElement.style.left);
      const toolbarWidth = this.toolbarElement.offsetWidth;
      const showButtonLeft = toolbarLeft + toolbarWidth - showButtonWidth;

      this.showButtonElement.style.left = `${showButtonLeft}px`;
      this.showButtonElement.style.top = this.toolbarElement.style.top;
      this.showButtonElement.style.right = 'auto';
    }

    this.toolbarElement.style.display = 'none';
    this.showButtonElement.style.display = 'flex';
    this.hideToolbarHint();
  }

  showToolbar() {
    // è¡¨ç¤ºãƒœã‚¿ãƒ³ã®ä½ç½®ã‹ã‚‰ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®ä½ç½®ã‚’è¨ˆç®—ï¼ˆå³ç«¯ã«åˆã‚ã›ã‚‹ï¼‰
    if (this.showButtonElement.style.left && this.showButtonElement.style.top) {
      const showButtonLeft = parseInt(this.showButtonElement.style.left);
      const showButtonWidth = 50; // è¡¨ç¤ºãƒœã‚¿ãƒ³ã®å¹…

      // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãŒè¡¨ç¤ºã•ã‚ŒãŸå¾Œã«å¹…ã‚’å–å¾—ã™ã‚‹ãŸã‚ã€ä¸€æ™‚çš„ã«è¡¨ç¤º
      this.toolbarElement.style.display = 'flex';
      this.toolbarElement.style.visibility = 'hidden';

      const toolbarWidth = this.toolbarElement.offsetWidth;

      // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å·¦ç«¯ä½ç½®ã‚’è¨ˆç®—ï¼ˆè¡¨ç¤ºãƒœã‚¿ãƒ³ã®å³ç«¯ãŒãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã®å³ç«¯ã«ãªã‚‹ã‚ˆã†ã«ï¼‰
      const toolbarLeft = showButtonLeft + showButtonWidth - toolbarWidth;

      this.toolbarElement.style.left = `${toolbarLeft}px`;
      this.toolbarElement.style.top = this.showButtonElement.style.top;
      this.toolbarElement.style.right = 'auto';
      this.toolbarElement.style.visibility = 'visible';

      // æ–°ã—ã„ä½ç½®ã‚’ä¿å­˜
      this.saveToolbarPosition(
        toolbarLeft,
        parseInt(this.showButtonElement.style.top)
      );
    } else {
      this.toolbarElement.style.display = 'flex';
    }

    this.showButtonElement.style.display = 'none';
    this.hideToolbarHint();
  }

  toggleToolbar() {
    if (this.isToolbarHidden()) {
      this.showToolbar();
    } else {
      this.hideToolbar();
    }
  }

  isToolbarHidden() {
    return this.toolbarElement.style.display === 'none';
  }

  showToolbarHint() {
    const hint = document.createElement('div');
    hint.id = 'toolbar-hint';
    hint.innerHTML =
      'ğŸ“Œ ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãŒéš ã‚Œã¦ã„ã¾ã™ã€‚<kbd>F11</kbd> ã¾ãŸã¯ <kbd>Esc</kbd> ã§è¡¨ç¤º';
    hint.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 9999;
            opacity: 0.9;
            font-family: inherit;
        `;

    // æ—¢å­˜ã®ãƒ’ãƒ³ãƒˆã‚’å‰Šé™¤
    this.hideToolbarHint();

    document.body.appendChild(hint);

    // 5ç§’å¾Œã«è‡ªå‹•çš„ã«éš ã™
    setTimeout(() => {
      this.hideToolbarHint();
    }, 5000);
  }

  hideToolbarHint() {
    const hint = document.getElementById('toolbar-hint');
    if (hint) {
      hint.remove();
    }
  }

  destroy() {
    if (this.toolbarElement) {
      this.toolbarElement.remove();
    }

    if (this.themeManager) {
      this.themeManager.destroy();
    }

    if (this.searchEngine) {
      this.searchEngine.destroy();
    }

    if (this.tocGenerator) {
      this.tocGenerator.destroy();
    }

    document.body.style.paddingTop = '';
  }

  exportAsHTML() {
    try {
      console.log('HTML Export attempted');

      // ã‚µãƒ³ãƒ‰ãƒœãƒƒã‚¯ã‚¹ç’°å¢ƒã®æ¤œå‡º
      const isSandboxed = this.detectSandboxEnvironment();

      if (isSandboxed) {
        console.log('HTML export blocked in sandbox environment');
        this.showExportErrorMessage();
        return;
      }

      // HTMLç”Ÿæˆã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      const htmlContent = this.generateCompleteHTML();
      this.downloadHTMLFile(htmlContent);
      this.showExportSuccessMessage();
    } catch (error) {
      console.error('HTML export failed:', error);
      this.showExportErrorMessage();
    }
  }

  // PDFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’å‰Šé™¤ã—ã¾ã—ãŸ
  // ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã•ã‚ŒãŸã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ¼ãƒ‰ç°¡ç´ åŒ–ã®ãŸã‚å‰Šé™¤

  // ä»¥ä¸‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€PDFé–¢é€£ã®å¤§é‡ã‚³ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ:
  // - exportAsPDF()
  // - generatePDF() 
  // - loadPDFLibraries()
  // - generateImageBasedPDF()
  // - generateDirectPDF()
  // - addElementToPDF()
  // - addTextToPDF()
  // - getTextHeight()
  // - prepareElementsForPDF()
  // - renderOptimizedPDF()
  // - renderSafePDF()
  // - fallbackToPrintDialog()
  // - applyPrintStyles()
  // - removePrintStyles()
  // - showPDFGeneratingMessage()
  // - showPDFDirectSuccessMessage()
  // - showPDFSuccessMessage()
  // - removePDFMessages()
  // - showPDFErrorMessage()

  // é‡è¤‡ã—ãŸæ—§showExportSuccessMessageãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‰Šé™¤ã—ã¾ã—ãŸ

  async generatePDF() {
    try {
      // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
      console.log('PDF generation started');
      console.log('window.jsPDF:', typeof window.jsPDF);
      console.log('window.html2canvas:', typeof window.html2canvas);

      // å¿…è¦ãªãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’å‹•çš„ã«èª­ã¿è¾¼ã¿
      const librariesLoaded = await this.loadPDFLibraries();

      if (!librariesLoaded) {
        console.warn(
          'PDF libraries not available, falling back to print dialog'
        );
        this.fallbackToPrintDialog();
        return;
      }

      // ç”Ÿæˆé–‹å§‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
      this.showPDFGeneratingMessage();
      console.log('Starting image-based PDF generation...');

      // ç”»åƒãƒ™ãƒ¼ã‚¹ã§PDFç”Ÿæˆã‚’è©¦è¡Œï¼ˆæ—¥æœ¬èªæ–‡å­—åŒ–ã‘å¯¾ç­–ï¼‰
      const success = await this.generateImageBasedPDF();

      if (success) {
        console.log('Direct PDF generation successful');
        this.showPDFDirectSuccessMessage();
      } else {
        console.log(
          'Direct PDF generation failed, falling back to print dialog'
        );
        // å¤±æ•—ã—ãŸå ´åˆã¯å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        this.fallbackToPrintDialog();
      }
    } catch (error) {
      console.error('PDF generation failed:', error);
      this.fallbackToPrintDialog();
    }
  }

  async loadPDFLibraries() {
    try {
      // æ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
      const jsPDFAvailable =
        typeof window.jsPDF !== 'undefined' ||
        typeof window.jspdf !== 'undefined' ||
        typeof jsPDF !== 'undefined';
      const html2canvasAvailable = typeof window.html2canvas !== 'undefined';

      if (jsPDFAvailable && html2canvasAvailable) {
        console.log('âœ… PDF libraries already loaded');
        return true;
      }

      console.log('ğŸ”„ Loading PDF libraries dynamically...');

      // LibraryLoaderãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆcontent.jsç”±æ¥ï¼‰
      if (
        typeof LibraryLoader !== 'undefined' &&
        LibraryLoader.loadExportLibraries
      ) {
        return await LibraryLoader.loadExportLibraries();
      }

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç‹¬è‡ªå®Ÿè£…ã§å‹•çš„èª­ã¿è¾¼ã¿
      const loadScript = src => {
        return new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = chrome.runtime.getURL(src);
          script.onload = () => {
            console.log(`âœ… Loaded: ${src}`);
            resolve();
          };
          script.onerror = () => {
            console.error(`âŒ Failed to load: ${src}`);
            reject(new Error(`Failed to load ${src}`));
          };
          document.head.appendChild(script);
        });
      };

      await Promise.all([
        loadScript('lib/jspdf.umd.min.js'),
        loadScript('lib/html2canvas.min.js'),
      ]);

      console.log('âœ… PDF libraries loaded successfully');
      return true;
    } catch (error) {
      console.error('âŒ Failed to load PDF libraries:', error);
      return false;
    }
  }

  loadScript(src) {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = src;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }

  async generateImageBasedPDF() {
    try {
      const markdownContent = document.getElementById('markdown-content');
      if (!markdownContent) {
        throw new Error('Markdown content not found');
      }

      // ã‚ˆã‚Šå®‰å…¨ãªæ”¹ãƒšãƒ¼ã‚¸åˆ¶å¾¡ã§PDFã‚’ç”Ÿæˆ
      const canvas = await this.renderSafePDF(markdownContent);

      // jsPDFã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
      let jsPDFClass;
      if (window.jsPDF) {
        jsPDFClass = window.jsPDF.jsPDF || window.jsPDF;
      } else if (window.jspdf) {
        jsPDFClass = window.jspdf.jsPDF || window.jspdf;
      } else if (typeof jsPDF !== 'undefined') {
        jsPDFClass = jsPDF;
      }

      const pdf = new jsPDFClass('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const marginX = 4; // æ¨ªã®ä½™ç™½ã‚’4mmã«
      const marginY = 5; // ç¸¦ã®ä½™ç™½ã‚’5mmã«

      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ã‚µã‚¤ã‚ºã‚’å–å¾—
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;

      // PDFãƒšãƒ¼ã‚¸ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
      const availableWidth = pageWidth - marginX * 2;
      const availableHeight = pageHeight - marginY * 2;

      // ç”»åƒã‚’ç¸®å°ã—ã¦è¡¨ç¤ºï¼ˆ65%ã®ã‚µã‚¤ã‚ºï¼‰
      const imgWidth = availableWidth * 0.65;
      const imgHeight = (canvasHeight * imgWidth) / canvasWidth;

      // ä¸­å¤®é…ç½®ã®ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
      const offsetX = marginX + (availableWidth - imgWidth) / 2;

      // å¿…è¦ãªãƒšãƒ¼ã‚¸æ•°ã‚’è¨ˆç®—
      const totalPages = Math.ceil(imgHeight / availableHeight);

      for (let page = 0; page < totalPages; page++) {
        if (page > 0) {
          pdf.addPage();
        }

        // å„ãƒšãƒ¼ã‚¸ã®é–‹å§‹ä½ç½®ã‚’è¨ˆç®—
        const sourceY = (page * availableHeight * canvasHeight) / imgHeight;
        const sourceHeight = Math.min(
          (availableHeight * canvasHeight) / imgHeight,
          canvasHeight - sourceY
        );

        // ãƒšãƒ¼ã‚¸ã”ã¨ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
        const pageCanvas = document.createElement('canvas');
        const pageCtx = pageCanvas.getContext('2d');
        pageCanvas.width = canvasWidth;
        pageCanvas.height = sourceHeight;

        // å…ƒã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰è©²å½“éƒ¨åˆ†ã‚’ã‚³ãƒ”ãƒ¼
        pageCtx.drawImage(
          canvas,
          0,
          sourceY,
          canvasWidth,
          sourceHeight,
          0,
          0,
          canvasWidth,
          sourceHeight
        );

        // ãƒšãƒ¼ã‚¸ã®å®Ÿéš›ã®é«˜ã•
        const pageImgHeight = (sourceHeight * imgWidth) / canvasWidth;

        // PDFã«ç”»åƒã‚’è¿½åŠ ï¼ˆä¸­å¤®é…ç½®ï¼‰
        const pageImgData = pageCanvas.toDataURL('image/jpeg', 0.85);
        pdf.addImage(
          pageImgData,
          'JPEG',
          offsetX,
          marginY,
          imgWidth,
          pageImgHeight
        );
      }

      // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
      const timestamp = new Date()
        .toISOString()
        .slice(0, 19)
        .replace(/:/g, '-');
      const title = document.title || 'markdown-document';
      const filename = `${title.replace(/[^a-zA-Z0-9]/g, '_')}-${timestamp}.pdf`;

      // PDFã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      pdf.save(filename);

      return true;
    } catch (error) {
      console.error('Image-based PDF generation failed:', error);
      return false;
    }
  }

  async generateDirectPDF() {
    try {
      const markdownContent = document.getElementById('markdown-content');
      if (!markdownContent) {
        throw new Error('Markdown content not found');
      }

      // jsPDFã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆ
      let jsPDFClass;
      if (window.jsPDF) {
        jsPDFClass = window.jsPDF.jsPDF || window.jsPDF;
      } else if (window.jspdf) {
        jsPDFClass = window.jspdf.jsPDF || window.jspdf;
      } else if (typeof jsPDF !== 'undefined') {
        jsPDFClass = jsPDF;
      }

      console.log('jsPDFClass:', jsPDFClass);
      const pdf = new jsPDFClass('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const marginX = 4;
      const marginY = 5;
      const availableWidth = pageWidth - marginX * 2;
      const availableHeight = pageHeight - marginY * 2;

      let currentY = marginY;
      let _currentPage = 1;

      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚©ãƒ³ãƒˆã‚’è¨­å®šï¼ˆæ—¥æœ¬èªå¯¾å¿œï¼‰
      pdf.setFontSize(12);
      // helveticaã¯é™å®šçš„ã§ã™ãŒåŸºæœ¬çš„ãªæ—¥æœ¬èªæ–‡å­—ã‚’è¡¨ç¤ºã§ãã¾ã™
      pdf.setFont('helvetica', 'normal');

      // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¿½åŠ 
      const title = document.title || 'Markdown Document';
      pdf.setFontSize(16);
      pdf.setFont('helvetica', 'bold');
      currentY += this.addTextToPDF(
        pdf,
        title,
        marginX,
        currentY,
        availableWidth
      );
      currentY += 10;

      // æ—¥ä»˜ã‚’è¿½åŠ 
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      const date = new Date().toLocaleString();
      currentY += this.addTextToPDF(
        pdf,
        `ç”Ÿæˆæ—¥æ™‚: ${date}`,
        marginX,
        currentY,
        availableWidth
      );
      currentY += 10;

      // åŒºåˆ‡ã‚Šç·š
      pdf.line(marginX, currentY, pageWidth - marginX, currentY);
      currentY += 10;

      // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’è¦ç´ ã”ã¨ã«å‡¦ç†
      const elements = markdownContent.children;
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const result = await this.addElementToPDF(
          pdf,
          element,
          marginX,
          currentY,
          availableWidth,
          availableHeight,
          pageHeight
        );
        currentY = result.y;

        // ãƒšãƒ¼ã‚¸ãŒå¤‰ã‚ã£ãŸå ´åˆã®å‡¦ç†
        if (result.newPage) {
          _currentPage++;
          currentY = marginY + 10; // æ–°ã—ã„ãƒšãƒ¼ã‚¸ã®é–‹å§‹ä½ç½®
        }
      }

      // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ
      const timestamp = new Date()
        .toISOString()
        .slice(0, 19)
        .replace(/:/g, '-');
      const filename = `${title.replace(/[^a-zA-Z0-9]/g, '_')}-${timestamp}.pdf`;

      // PDFã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      pdf.save(filename);

      return true;
    } catch (error) {
      console.error('Direct PDF generation failed:', error);
      return false;
    }
  }

  async addElementToPDF(pdf, element, x, y, maxWidth, maxHeight, pageHeight) {
    const tagName = element.tagName.toLowerCase();
    let currentY = y;
    let newPage = false;

    // ãƒšãƒ¼ã‚¸ã®æ®‹ã‚Šé«˜ã•ã‚’ãƒã‚§ãƒƒã‚¯
    const checkPageBreak = requiredHeight => {
      if (currentY + requiredHeight > pageHeight - 15) {
        pdf.addPage();
        currentY = 15 + 20; // ãƒãƒ¼ã‚¸ãƒ³ + ãƒ˜ãƒƒãƒ€ãƒ¼ç©ºé–“
        return true;
      }
      return false;
    };

    switch (tagName) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        const level = parseInt(tagName.charAt(1));
        const fontSize = Math.max(16 - level, 10);

        newPage = checkPageBreak(fontSize + 10);

        pdf.setFontSize(fontSize);
        pdf.setFont('helvetica', 'bold');
        currentY += this.addTextToPDF(
          pdf,
          element.textContent,
          x,
          currentY,
          maxWidth
        );
        currentY += 8;

        // H1ã¨H2ã«ã¯ä¸‹ç·šã‚’è¿½åŠ 
        if (level <= 2) {
          pdf.line(x, currentY - 3, x + maxWidth, currentY - 3);
          currentY += 5;
        }
        break;

      case 'p':
        newPage = checkPageBreak(20);

        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'normal');
        currentY += this.addTextToPDF(
          pdf,
          element.textContent,
          x,
          currentY,
          maxWidth
        );
        currentY += 6;
        break;

      case 'ul':
      case 'ol':
        newPage = checkPageBreak(30);

        const listItems = element.querySelectorAll('li');
        for (let i = 0; i < listItems.length; i++) {
          const item = listItems[i];
          const prefix = tagName === 'ul' ? 'â€¢ ' : `${i + 1}. `;

          pdf.setFontSize(12);
          pdf.setFont('helvetica', 'normal');
          currentY += this.addTextToPDF(
            pdf,
            prefix + item.textContent,
            x + 10,
            currentY,
            maxWidth - 10
          );
          currentY += 3;

          // ãƒªã‚¹ãƒˆé …ç›®ã§ã‚‚ãƒšãƒ¼ã‚¸ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
          if (checkPageBreak(15)) {
            newPage = true;
          }
        }
        currentY += 6;
        break;

      case 'blockquote':
        newPage = checkPageBreak(25);

        pdf.setFontSize(11);
        pdf.setFont('helvetica', 'normal');

        // å·¦å´ã«ç¸¦ç·šã‚’æç”»
        pdf.line(x, currentY, x, currentY + 20);

        currentY += this.addTextToPDF(
          pdf,
          element.textContent,
          x + 10,
          currentY,
          maxWidth - 10
        );
        currentY += 8;
        break;

      case 'pre':
      case 'code':
        newPage = checkPageBreak(30);

        pdf.setFontSize(10);
        pdf.setFont('courier', 'normal');

        // èƒŒæ™¯è‰²ã‚’è¨­å®šï¼ˆè–„ã„ã‚°ãƒ¬ãƒ¼ï¼‰
        pdf.setFillColor(245, 245, 245);
        const textHeight = this.getTextHeight(
          pdf,
          element.textContent,
          maxWidth - 20
        );
        pdf.rect(x, currentY - 2, maxWidth, textHeight + 8, 'F');

        currentY += this.addTextToPDF(
          pdf,
          element.textContent,
          x + 5,
          currentY + 3,
          maxWidth - 10
        );
        currentY += 10;
        break;

      case 'table':
        // ãƒ†ãƒ¼ãƒ–ãƒ«ã¯ç”»åƒã¨ã—ã¦å‡¦ç†
        try {
          const canvas = await html2canvas(element, {
            useCORS: true,
            backgroundColor: '#ffffff',
          });

          const imgData = canvas.toDataURL('image/png');
          const imgWidth = maxWidth;
          const imgHeight = (canvas.height * maxWidth) / canvas.width;

          newPage = checkPageBreak(imgHeight + 10);

          pdf.addImage(imgData, 'PNG', x, currentY, imgWidth, imgHeight);
          currentY += imgHeight + 10;
        } catch (error) {
          console.warn('Failed to render table as image:', error);
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦å‡¦ç†
          currentY += this.addTextToPDF(
            pdf,
            element.textContent,
            x,
            currentY,
            maxWidth
          );
          currentY += 10;
        }
        break;

      case 'div':
        // Mermaidå›³ãªã©ã®ç‰¹æ®Šè¦ç´ 
        if (element.classList.contains('mermaid')) {
          try {
            const canvas = await html2canvas(element, {
              useCORS: true,
              backgroundColor: '#ffffff',
            });

            const imgData = canvas.toDataURL('image/png');
            const imgWidth = maxWidth;
            const imgHeight = (canvas.height * maxWidth) / canvas.width;

            newPage = checkPageBreak(imgHeight + 10);

            pdf.addImage(imgData, 'PNG', x, currentY, imgWidth, imgHeight);
            currentY += imgHeight + 10;
          } catch (error) {
            console.warn('Failed to render mermaid diagram:', error);
          }
        } else {
          // é€šå¸¸ã®divã¯å†å¸°çš„ã«å‡¦ç†
          for (const child of element.children) {
            const result = await this.addElementToPDF(
              pdf,
              child,
              x,
              currentY,
              maxWidth,
              maxHeight,
              pageHeight
            );
            currentY = result.y;
            if (result.newPage) {
              newPage = true;
            }
          }
        }
        break;

      default:
        // ãã®ä»–ã®è¦ç´ ã¯ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦å‡¦ç†
        if (element.textContent.trim()) {
          pdf.setFontSize(12);
          pdf.setFont('helvetica', 'normal');
          currentY += this.addTextToPDF(
            pdf,
            element.textContent,
            x,
            currentY,
            maxWidth
          );
          currentY += 6;
        }
        break;
    }

    return { y: currentY, newPage };
  }

  addTextToPDF(pdf, text, x, y, maxWidth) {
    const lines = pdf.splitTextToSize(text, maxWidth);
    pdf.text(lines, x, y);
    return lines.length * 5; // è¡Œã®é«˜ã• Ã— è¡Œæ•°
  }

  getTextHeight(pdf, text, maxWidth) {
    const lines = pdf.splitTextToSize(text, maxWidth);
    return lines.length * 5;
  }

  async prepareElementsForPDF(markdownContent) {
    // PDFç”¨ã«è¦ç´ ã‚’åˆ†æãƒ»åˆ†é¡
    const elements = [];
    const children = Array.from(markdownContent.children);

    for (const child of children) {
      const elementInfo = await this.analyzeElement(child);
      elements.push(elementInfo);
    }

    console.log('Analyzed elements for PDF:', elements.length);
    return elements;
  }

  async analyzeElement(element) {
    const rect = element.getBoundingClientRect();
    const tagName = element.tagName.toLowerCase();

    // è¦ç´ ã‚¿ã‚¤ãƒ—ã®åˆ¤å®š
    let elementType = 'text';
    let breakBehavior = 'allow'; // allow, avoid, force-before

    // ã‚ˆã‚Šè©³ç´°ãªè¦ç´ æ¤œå‡º
    if (
      tagName === 'pre' ||
      element.classList.contains('highlight') ||
      element.classList.contains('code')
    ) {
      elementType = 'code';
      breakBehavior = 'avoid';
    } else if (
      element.classList.contains('mermaid') ||
      element.querySelector('.mermaid')
    ) {
      elementType = 'diagram';
      breakBehavior = 'avoid';
    } else if (tagName === 'table') {
      elementType = 'table';
      breakBehavior = 'avoid';
    } else if (tagName.match(/^h[1-6]$/)) {
      elementType = 'heading';
      breakBehavior = 'force-before';
    } else if (tagName === 'blockquote') {
      elementType = 'quote';
      breakBehavior = 'avoid';
    } else if (tagName === 'img') {
      elementType = 'image';
      breakBehavior = 'avoid';
    } else if (element.querySelector('img, svg, canvas')) {
      // å†…éƒ¨ã«ç”»åƒè¦ç´ ã‚’å«ã‚€å ´åˆ
      elementType = 'image-container';
      breakBehavior = 'avoid';
    } else if (element.querySelector('pre, .mermaid, table')) {
      // å†…éƒ¨ã«åˆ†å‰²ç¦æ­¢è¦ç´ ã‚’å«ã‚€å ´åˆ
      elementType = 'container';
      breakBehavior = 'avoid';
    }

    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¿½åŠ 
    if (breakBehavior === 'avoid') {
      console.log(
        `Found avoid-break element: ${elementType}, height: ${rect.height}px, class: ${element.className}`
      );
    }

    return {
      element: element,
      type: elementType,
      breakBehavior: breakBehavior,
      height: rect.height,
      width: rect.width,
      tagName: tagName,
    };
  }

  async renderOptimizedPDF(elements) {
    // ä¸€æ™‚çš„ãªã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
    const tempContainer = document.createElement('div');
    tempContainer.style.cssText = `
            position: absolute;
            top: -10000px;
            left: -10000px;
            width: 800px;
            background: white;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.8;
            letter-spacing: 0.5px;
            word-spacing: 1px;
            font-size: 14px;
        `;

    document.body.appendChild(tempContainer);

    try {
      // ãƒšãƒ¼ã‚¸ã”ã¨ã«è¦ç´ ã‚’é…ç½®
      const pages = await this.layoutElementsIntoPages(elements, tempContainer);

      // å„ãƒšãƒ¼ã‚¸ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      const pageCanvases = [];
      for (const page of pages) {
        const canvas = await this.renderPage(page, tempContainer);
        pageCanvases.push(canvas);
      }

      // å…¨ãƒšãƒ¼ã‚¸ã‚’çµåˆ
      const combinedCanvas = this.combinePageCanvases(pageCanvases);

      return combinedCanvas;
    } finally {
      document.body.removeChild(tempContainer);
    }
  }

  async layoutElementsIntoPages(elements, _container) {
    const pages = [];
    let currentPage = [];
    let currentPageHeight = 0;
    const pageHeight = 800; // ã‚ˆã‚Šå°ã•ãªãƒšãƒ¼ã‚¸é«˜ã•ã§å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³ã‚’ç¢ºä¿
    const safetyMargin = 100; // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³

    console.log('Starting page layout with', elements.length, 'elements');

    for (let i = 0; i < elements.length; i++) {
      const elementInfo = elements[i];
      const elementHeight = Math.max(elementInfo.height, 30);

      console.log(
        `Processing element ${i}: ${elementInfo.type}, height: ${elementHeight}px, breakBehavior: ${elementInfo.breakBehavior}`
      );

      // è¦‹å‡ºã—ã®å‰ã¯æ”¹ãƒšãƒ¼ã‚¸ã‚’æ¨å¥¨
      if (
        elementInfo.breakBehavior === 'force-before' &&
        currentPage.length > 0
      ) {
        console.log('Force page break before heading');
        pages.push([...currentPage]);
        currentPage = [];
        currentPageHeight = 0;
      }

      // è¦ç´ ãŒãƒšãƒ¼ã‚¸ã«åã¾ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const willFitInCurrentPage =
        currentPageHeight + elementHeight + safetyMargin <= pageHeight;

      if (!willFitInCurrentPage && currentPage.length > 0) {
        if (elementInfo.breakBehavior === 'avoid') {
          // åˆ†å‰²ã§ããªã„è¦ç´ ã¯å¿…ãšæ–°ã—ã„ãƒšãƒ¼ã‚¸ã«
          console.log(`Moving ${elementInfo.type} to new page (avoid break)`);
          pages.push([...currentPage]);
          currentPage = [];
          currentPageHeight = 0;
        } else {
          // åˆ†å‰²å¯èƒ½ãªè¦ç´ ã‚‚åŸºæœ¬çš„ã«ã¯æ–°ã—ã„ãƒšãƒ¼ã‚¸ã«
          console.log(`Moving ${elementInfo.type} to new page (normal break)`);
          pages.push([...currentPage]);
          currentPage = [];
          currentPageHeight = 0;
        }
      }

      // è¦ç´ ãŒå˜ä½“ã§ãƒšãƒ¼ã‚¸é«˜ã•ã‚’è¶…ãˆã‚‹å ´åˆã®è­¦å‘Š
      if (elementHeight > pageHeight) {
        console.warn(
          `Element ${elementInfo.type} (${elementHeight}px) exceeds page height (${pageHeight}px)`
        );
      }

      currentPage.push(elementInfo);
      currentPageHeight += elementHeight;

      console.log(`Added to page, current height: ${currentPageHeight}px`);
    }

    // æœ€å¾Œã®ãƒšãƒ¼ã‚¸ã‚’è¿½åŠ 
    if (currentPage.length > 0) {
      pages.push(currentPage);
    }

    console.log(`Created ${pages.length} pages with optimized layout`);
    console.log(
      'Pages:',
      pages.map((page, i) => `Page ${i + 1}: ${page.length} elements`)
    );

    return pages;
  }

  async renderPage(pageElements, container) {
    // ãƒšãƒ¼ã‚¸è¦ç´ ã‚’ã‚³ãƒ³ãƒ†ãƒŠã«é…ç½®
    container.innerHTML = '';

    pageElements.forEach(elementInfo => {
      const clonedElement = elementInfo.element.cloneNode(true);

      // ã‚¹ã‚¿ã‚¤ãƒ«èª¿æ•´ã¨æŠ˜ã‚Šè¿”ã—è¨­å®š
      clonedElement.style.wordWrap = 'break-word';
      clonedElement.style.wordBreak = 'break-word';
      clonedElement.style.overflowWrap = 'break-word';
      clonedElement.style.maxWidth = '100%';

      if (elementInfo.tagName === 'p') {
        clonedElement.style.marginBottom = '12px';
        clonedElement.style.lineHeight = '1.5';
        clonedElement.style.whiteSpace = 'normal';
      } else if (elementInfo.tagName.match(/^h[1-6]$/)) {
        clonedElement.style.marginTop = '20px';
        clonedElement.style.marginBottom = '12px';
        clonedElement.style.lineHeight = '1.4';
        clonedElement.style.whiteSpace = 'normal';
      } else if (elementInfo.tagName === 'li') {
        clonedElement.style.marginBottom = '6px';
        clonedElement.style.lineHeight = '1.5';
        clonedElement.style.whiteSpace = 'normal';
      } else if (
        elementInfo.tagName === 'pre' ||
        elementInfo.tagName === 'code'
      ) {
        clonedElement.style.whiteSpace = 'pre-wrap';
        clonedElement.style.wordBreak = 'break-all';
      }

      container.appendChild(clonedElement);
    });

    // html2canvasã§ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
    const canvas = await html2canvas(container, {
      useCORS: true,
      scale: 1.5,
      backgroundColor: '#ffffff',
      logging: false,
      letterRendering: true,
      allowTaint: false,
      foreignObjectRendering: false,
    });

    return canvas;
  }

  combinePageCanvases(pageCanvases) {
    if (pageCanvases.length === 0) {
      return null;
    }
    if (pageCanvases.length === 1) {
      return pageCanvases[0];
    }

    // å…¨ãƒšãƒ¼ã‚¸ã®é«˜ã•ã‚’è¨ˆç®—
    const totalWidth = pageCanvases[0].width;
    const totalHeight = pageCanvases.reduce(
      (sum, canvas) => sum + canvas.height,
      0
    );

    // çµåˆã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
    const combinedCanvas = document.createElement('canvas');
    combinedCanvas.width = totalWidth;
    combinedCanvas.height = totalHeight;

    const ctx = combinedCanvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, totalWidth, totalHeight);

    // ãƒšãƒ¼ã‚¸ã‚’ç¸¦ã«çµåˆ
    let currentY = 0;
    pageCanvases.forEach(canvas => {
      ctx.drawImage(canvas, 0, currentY);
      currentY += canvas.height;
    });

    return combinedCanvas;
  }

  async renderSafePDF(markdownContent) {
    try {
      // html2canvasã§å…¨ä½“ã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
      const fullCanvas = await html2canvas(markdownContent, {
        useCORS: true,
        scale: 1.5,
        backgroundColor: '#ffffff',
        logging: false,
        letterRendering: true,
        allowTaint: false,
        foreignObjectRendering: false,
        onclone: clonedDoc => {
          // ã‚¯ãƒ­ãƒ¼ãƒ³ã•ã‚ŒãŸãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãªã©ã‚’éè¡¨ç¤º
          const elementsToHide = clonedDoc.querySelectorAll(
            '.main-toolbar, .toc-panel, .search-panel, .toc-floating-button'
          );
          elementsToHide.forEach(el => (el.style.display = 'none'));

          // è¡Œé–“ã¨æ–‡å­—é–“éš”ã‚’èª¿æ•´
          const markdownContentClone =
            clonedDoc.querySelector('#markdown-content');
          if (markdownContentClone) {
            markdownContentClone.style.lineHeight = '1.5';
            markdownContentClone.style.letterSpacing = '0.5px';
            markdownContentClone.style.wordSpacing = '1px';
            markdownContentClone.style.fontSize = '14px';
            markdownContentClone.style.wordWrap = 'break-word';
            markdownContentClone.style.wordBreak = 'break-word';
            markdownContentClone.style.whiteSpace = 'normal';
            markdownContentClone.style.maxWidth = '100%';
            markdownContentClone.style.overflowWrap = 'break-word';

            // åˆ†å‰²ç¦æ­¢è¦ç´ ã«ãƒãƒ¼ã‚­ãƒ³ã‚°
            this.markAvoidBreakElements(markdownContentClone);

            // å…¨ã¦ã®è¦ç´ ã«ä½™ç™½ã¨æŠ˜ã‚Šè¿”ã—ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ 
            const allElements = markdownContentClone.querySelectorAll('*');
            allElements.forEach(el => {
              // å…¨è¦ç´ ã«æŠ˜ã‚Šè¿”ã—ã‚¹ã‚¿ã‚¤ãƒ«ã‚’é©ç”¨
              el.style.wordWrap = 'break-word';
              el.style.wordBreak = 'break-word';
              el.style.overflowWrap = 'break-word';
              el.style.maxWidth = '100%';

              if (el.tagName === 'P') {
                el.style.marginBottom = '12px';
                el.style.lineHeight = '1.5';
                el.style.whiteSpace = 'normal';
              }
              if (el.tagName.match(/^H[1-6]$/)) {
                el.style.marginTop = '20px';
                el.style.marginBottom = '12px';
                el.style.lineHeight = '1.4';
                el.style.whiteSpace = 'normal';
              }
              if (el.tagName === 'LI') {
                el.style.marginBottom = '6px';
                el.style.lineHeight = '1.5';
                el.style.whiteSpace = 'normal';
              }
              if (el.tagName === 'PRE' || el.tagName === 'CODE') {
                el.style.whiteSpace = 'pre-wrap';
                el.style.wordBreak = 'break-all';
              }
            });
          }
        },
      });

      // å®‰å…¨ãªæ”¹ãƒšãƒ¼ã‚¸å‡¦ç†
      return this.applySafePageBreaks(fullCanvas, markdownContent);
    } catch (error) {
      console.error('Safe PDF rendering failed:', error);
      throw error;
    }
  }

  markAvoidBreakElements(container) {
    // åˆ†å‰²ç¦æ­¢è¦ç´ ã‚’ç‰¹å®šã—ã¦ãƒãƒ¼ã‚­ãƒ³ã‚°
    const avoidBreakSelectors = [
      'pre',
      'code',
      '.mermaid',
      'table',
      'blockquote',
      'img',
      '[class*="highlight"]',
      '[class*="code"]',
    ];

    avoidBreakSelectors.forEach(selector => {
      const elements = container.querySelectorAll(selector);
      elements.forEach(el => {
        el.style.border = '1px solid rgba(255,0,0,0.1)'; // ãƒ‡ãƒãƒƒã‚°ç”¨ã®è–„ã„å¢ƒç•Œç·š
        el.dataset.avoidBreak = 'true';
      });
    });
  }

  async applySafePageBreaks(fullCanvas, originalContent) {
    const pageHeight = 1100; // A4ç›¸å½“ã®é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
    const safeMargin = 50; // å®‰å…¨ãƒãƒ¼ã‚¸ãƒ³
    const effectivePageHeight = pageHeight - safeMargin;

    // åˆ†å‰²ç¦æ­¢é ˜åŸŸã‚’ç‰¹å®š
    const avoidBreakAreas = await this.identifyAvoidBreakAreas(originalContent);

    // è¡Œé–“ã§ã®åˆ†å‰²ç‚¹ã‚’è¨ˆç®—
    const lineBasedBreakPoints = await this.calculateLineBasedBreakPoints(
      fullCanvas,
      originalContent,
      effectivePageHeight,
      avoidBreakAreas
    );

    console.log('Line-based break points:', lineBasedBreakPoints);
    console.log('Avoid break areas:', avoidBreakAreas);

    // åˆ†å‰²ç‚¹ã«åŸºã¥ã„ã¦ãƒšãƒ¼ã‚¸ã‚’ä½œæˆ
    return this.createPagesFromBreakPoints(
      fullCanvas,
      lineBasedBreakPoints,
      pageHeight
    );
  }

  async identifyAvoidBreakAreas(originalContent) {
    const avoidAreas = [];
    const scale = 1.5; // html2canvasã®ã‚¹ã‚±ãƒ¼ãƒ«ã«åˆã‚ã›ã‚‹

    // åˆ†å‰²ç¦æ­¢è¦ç´ ã®ä½ç½®ã‚’å–å¾—
    const avoidSelectors = [
      'pre',
      'code:not(pre code)', // preå†…ã®codeã¯é™¤å¤–
      '.mermaid',
      'table',
      'blockquote',
      'img',
    ];

    for (const selector of avoidSelectors) {
      const elements = originalContent.querySelectorAll(selector);
      for (const element of elements) {
        const rect = element.getBoundingClientRect();
        const contentRect = originalContent.getBoundingClientRect();

        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„å†…ã§ã®ç›¸å¯¾ä½ç½®ã‚’è¨ˆç®—
        const relativeTop = (rect.top - contentRect.top) * scale;
        const relativeBottom = relativeTop + rect.height * scale;

        if (rect.height > 10) {
          // æ¥µå°è¦ç´ ã¯é™¤å¤–
          avoidAreas.push({
            start: Math.max(0, relativeTop - 10), // å°‘ã—ä½™è£•ã‚’æŒãŸã›ã‚‹
            end: relativeBottom + 10,
            height: rect.height * scale,
            element: element.tagName.toLowerCase(),
            class: element.className,
          });
        }
      }
    }

    // é‡è¤‡ã™ã‚‹é ˜åŸŸã‚’ãƒãƒ¼ã‚¸
    return this.mergeOverlappingAreas(avoidAreas);
  }

  mergeOverlappingAreas(areas) {
    if (areas.length === 0) {
      return areas;
    }

    // é–‹å§‹ä½ç½®ã§ã‚½ãƒ¼ãƒˆ
    areas.sort((a, b) => a.start - b.start);

    const merged = [areas[0]];

    for (let i = 1; i < areas.length; i++) {
      const current = areas[i];
      const last = merged[merged.length - 1];

      if (current.start <= last.end + 20) {
        // 20pxä»¥å†…ãªã‚‰çµåˆ
        last.end = Math.max(last.end, current.end);
        last.height = last.end - last.start;
      } else {
        merged.push(current);
      }
    }

    return merged;
  }

  calculateSafeBreakPoints(totalHeight, pageHeight, avoidAreas) {
    const breakPoints = [0]; // æœ€åˆã®ãƒšãƒ¼ã‚¸ã¯0ã‹ã‚‰é–‹å§‹
    let currentPosition = 0;

    while (currentPosition < totalHeight) {
      let nextBreakPoint = currentPosition + pageHeight;

      // æ¬¡ã®åˆ†å‰²ç‚¹ãŒåˆ†å‰²ç¦æ­¢é ˜åŸŸã¨é‡è¤‡ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      for (const area of avoidAreas) {
        // åˆ†å‰²ç‚¹ãŒåˆ†å‰²ç¦æ­¢é ˜åŸŸå†…ã«ã‚ã‚‹å ´åˆ
        if (nextBreakPoint > area.start && nextBreakPoint < area.end) {
          // é ˜åŸŸã®å‰ã§åˆ†å‰²ã™ã‚‹ã‹ã€å¾Œã§åˆ†å‰²ã™ã‚‹ã‹ã‚’æ±ºå®š
          const beforeDistance = nextBreakPoint - area.start;
          const afterDistance = area.end - nextBreakPoint;

          if (
            beforeDistance < afterDistance &&
            area.start > currentPosition + 100
          ) {
            // é ˜åŸŸã®å‰ã§åˆ†å‰²ï¼ˆãŸã ã—ã€æœ€å°é«˜ã•ã‚’ç¢ºä¿ï¼‰
            nextBreakPoint = area.start;
          } else {
            // é ˜åŸŸã®å¾Œã§åˆ†å‰²
            nextBreakPoint = area.end;
          }
          break;
        }
      }

      // æœ€å¾Œã®ãƒšãƒ¼ã‚¸ã®å‡¦ç†
      if (nextBreakPoint >= totalHeight) {
        break;
      }

      breakPoints.push(nextBreakPoint);
      currentPosition = nextBreakPoint;
    }

    return breakPoints;
  }

  async calculateLineBasedBreakPoints(
    fullCanvas,
    originalContent,
    pageHeight,
    avoidBreakAreas
  ) {
    const breakPoints = [0];
    let currentPosition = 0;
    const scale = 1.5;
    const lineHeight = 20 * scale; // æ¦‚ç®—è¡Œé«˜ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´æ¸ˆã¿ï¼‰

    // ãƒ†ã‚­ã‚¹ãƒˆè¦ç´ ã®è¡Œæƒ…å ±ã‚’å–å¾—
    const textLines = await this.identifyTextLines(originalContent, scale);

    console.log('Identified text lines:', textLines.length);

    while (currentPosition < fullCanvas.height) {
      let nextBreakPoint = currentPosition + pageHeight;

      // åˆ†å‰²ç¦æ­¢é ˜åŸŸã‚’ãƒã‚§ãƒƒã‚¯
      for (const area of avoidBreakAreas) {
        if (nextBreakPoint > area.start && nextBreakPoint < area.end) {
          // é ˜åŸŸã®å‰å¾Œã©ã¡ã‚‰ã§åˆ†å‰²ã™ã‚‹ã‹æ±ºå®š
          const beforeDistance = nextBreakPoint - area.start;
          const afterDistance = area.end - nextBreakPoint;

          if (
            beforeDistance < afterDistance &&
            area.start > currentPosition + 100
          ) {
            nextBreakPoint = area.start;
          } else {
            nextBreakPoint = area.end;
          }
          break;
        }
      }

      // æœ€ã‚‚è¿‘ã„è¡Œé–“ã‚’æ¢ã™
      const adjustedBreakPoint = this.findNearestLineGap(
        nextBreakPoint,
        textLines,
        lineHeight
      );

      if (adjustedBreakPoint >= fullCanvas.height) {
        break;
      }

      // æœ€å°ãƒšãƒ¼ã‚¸é«˜ã•ã‚’ç¢ºä¿
      if (adjustedBreakPoint - currentPosition > 200) {
        breakPoints.push(adjustedBreakPoint);
        currentPosition = adjustedBreakPoint;
      } else {
        // æœ€å°é«˜ã•ã«æº€ãŸãªã„å ´åˆã¯æ¬¡ã®ãƒšãƒ¼ã‚¸ã¾ã§å»¶é•·
        currentPosition = nextBreakPoint;
      }
    }

    return breakPoints;
  }

  async identifyTextLines(originalContent, scale) {
    const textLines = [];
    const textElements = originalContent.querySelectorAll(
      'p, h1, h2, h3, h4, h5, h6, li, td, th, div:not(.mermaid)'
    );

    for (const element of textElements) {
      // åˆ†å‰²ç¦æ­¢è¦ç´ ã¯é™¤å¤–
      if (
        element.tagName.toLowerCase() === 'pre' ||
        element.classList.contains('mermaid') ||
        element.closest('pre, .mermaid, table')
      ) {
        continue;
      }

      const rect = element.getBoundingClientRect();
      const contentRect = originalContent.getBoundingClientRect();

      if (rect.height < 5) {
        continue;
      } // æ¥µå°è¦ç´ ã¯é™¤å¤–

      const relativeTop = (rect.top - contentRect.top) * scale;
      const _relativeBottom = relativeTop + rect.height * scale;

      // è¦ç´ å†…ã®è¡Œã‚’æ¨å®š
      const lineHeight = this.getElementLineHeight(element) * scale;
      const actualLineHeight = lineHeight / scale;
      const lineCount = Math.max(1, Math.round(rect.height / actualLineHeight));

      // è¦ç´ ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°ã¨ãƒãƒ¼ã‚¸ãƒ³ã‚’è€ƒæ…®
      const computedStyle = window.getComputedStyle(element);
      const paddingTop = parseFloat(computedStyle.paddingTop) * scale;
      const _marginTop = parseFloat(computedStyle.marginTop) * scale;

      for (let i = 0; i < lineCount; i++) {
        const lineY = relativeTop + paddingTop + i * lineHeight;
        const lineBottom = lineY + lineHeight;

        textLines.push({
          y: lineY,
          height: lineHeight,
          bottom: lineBottom,
          element: element.tagName.toLowerCase(),
          canBreakAfter: true,
          paddingTop: paddingTop,
          actualHeight: actualLineHeight,
        });
      }
    }

    // Yåº§æ¨™ã§ã‚½ãƒ¼ãƒˆ
    textLines.sort((a, b) => a.y - b.y);

    return textLines;
  }

  getElementLineHeight(element) {
    const computedStyle = window.getComputedStyle(element);
    const lineHeight = computedStyle.lineHeight;
    const fontSize = parseFloat(computedStyle.fontSize);

    let calculatedLineHeight;

    if (lineHeight === 'normal') {
      // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®1.2å€ã‚’æ¦‚ç®—ï¼ˆã‚ˆã‚Šæ­£ç¢ºã«ï¼‰
      calculatedLineHeight = fontSize * 1.2;
    } else if (lineHeight.endsWith('px')) {
      calculatedLineHeight = parseFloat(lineHeight);
    } else if (lineHeight.match(/^\d+(\.\d+)?$/)) {
      // æ•°å€¤ã®ã¿ã®å ´åˆã¯ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã®å€æ•°
      calculatedLineHeight = fontSize * parseFloat(lineHeight);
    } else {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
      calculatedLineHeight = fontSize * 1.2;
    }

    // CSSè¨­å®šã•ã‚ŒãŸè¡Œé«˜ã‚’ç¢ºèª
    const cssLineHeight = parseFloat(getComputedStyle(element).lineHeight);
    if (!isNaN(cssLineHeight) && cssLineHeight > 0) {
      calculatedLineHeight = cssLineHeight;
    }

    // æœ€å°å€¤ã‚’ç¢ºä¿ï¼ˆæ–‡å­—ãŒèª­ã‚ã‚‹ç¨‹åº¦ï¼‰
    return Math.max(calculatedLineHeight, fontSize * 1.1);
  }

  findNearestLineGap(targetY, textLines, _defaultLineHeight) {
    let bestGap = targetY;
    let minDistance = Infinity;

    // ç›®æ¨™ä½ç½®ã®å‰å¾Œ80pxç¯„å›²ã§è¡Œé–“ã‚’æ¢ã™ï¼ˆç¯„å›²ã‚’æ‹¡å¤§ï¼‰
    const searchRange = 80;

    for (let i = 0; i < textLines.length - 1; i++) {
      const currentLine = textLines[i];
      const nextLine = textLines[i + 1];

      const currentLineEnd = currentLine.y + currentLine.height;
      const nextLineStart = nextLine.y;

      // è¡Œé–“ã®ã‚¹ãƒšãƒ¼ã‚¹ã‚’è¨ˆç®—
      const lineGapHeight = nextLineStart - currentLineEnd;

      if (lineGapHeight > 5) {
        // ååˆ†ãªè¡Œé–“ãŒã‚ã‚‹å ´åˆã®ã¿
        // è¡Œé–“ã®çœŸã‚“ä¸­ã§åˆ†å‰²
        const gapCenter = currentLineEnd + lineGapHeight / 2;

        // ç›®æ¨™ä½ç½®ã®å‰å¾Œç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
        if (Math.abs(gapCenter - targetY) <= searchRange) {
          const distance = Math.abs(gapCenter - targetY);
          if (distance < minDistance && currentLine.canBreakAfter) {
            minDistance = distance;
            bestGap = gapCenter;

            console.log(
              `Found perfect line gap: line1 end: ${currentLineEnd}, line2 start: ${nextLineStart}, gap center: ${gapCenter}, gap height: ${lineGapHeight}`
            );
          }
        }
      }
    }

    // è¡Œé–“ã®çœŸã‚“ä¸­ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã€è¡Œã®çµ‚ã‚ã‚Šã‹ã‚‰å°‘ã—ä¸‹ã§åˆ†å‰²
    if (minDistance === Infinity) {
      for (const line of textLines) {
        const lineEnd = line.y + line.height;
        const gapY = lineEnd + 8; // è¡Œã®çµ‚ã‚ã‚Šã‹ã‚‰8pxä¸‹ï¼ˆä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰

        if (Math.abs(gapY - targetY) <= searchRange) {
          const distance = Math.abs(gapY - targetY);
          if (distance < minDistance && line.canBreakAfter) {
            minDistance = distance;
            bestGap = gapY;
          }
        }
      }
    }

    console.log(
      `Found line gap at ${bestGap} (target: ${targetY}, distance: ${minDistance})`
    );

    return bestGap;
  }

  createPagesFromBreakPoints(fullCanvas, breakPoints, _pageHeight) {
    const pages = [];

    for (let i = 0; i < breakPoints.length; i++) {
      const startY = breakPoints[i];
      const endY =
        i < breakPoints.length - 1 ? breakPoints[i + 1] : fullCanvas.height;
      const actualHeight = endY - startY;

      // ãƒšãƒ¼ã‚¸ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ä½œæˆ
      const pageCanvas = document.createElement('canvas');
      pageCanvas.width = fullCanvas.width;
      pageCanvas.height = actualHeight;

      const ctx = pageCanvas.getContext('2d');
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, pageCanvas.width, pageCanvas.height);

      // è©²å½“éƒ¨åˆ†ã‚’ã‚³ãƒ”ãƒ¼
      ctx.drawImage(
        fullCanvas,
        0,
        startY,
        fullCanvas.width,
        actualHeight,
        0,
        0,
        pageCanvas.width,
        actualHeight
      );

      pages.push(pageCanvas);
    }

    console.log(`Created ${pages.length} pages with safe breaks`);

    // ãƒšãƒ¼ã‚¸ã‚’ç¸¦ã«çµåˆã—ã¦è¿”ã™
    return this.combinePageCanvases(pages);
  }

  fallbackToPrintDialog() {
    // å°åˆ·ç”¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¸€æ™‚çš„ã«é©ç”¨
    this.applyPrintStyles();

    // å°‘ã—é…å»¶ã—ã¦ã‹ã‚‰å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ã
    setTimeout(() => {
      try {
        // å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‹ãï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒPDFã‚’é¸æŠå¯èƒ½ï¼‰
        window.print();

        // å°åˆ·ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å…ƒã«æˆ»ã™
        setTimeout(() => {
          this.removePrintStyles();
        }, 1000);

        // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        this.showPDFSuccessMessage();
      } catch (error) {
        console.error('Print dialog failed:', error);
        this.removePrintStyles();
        this.showPDFErrorMessage();
      }
    }, 100);
  }

  applyPrintStyles() {
    // PDFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆç”¨ã®ä¸€æ™‚ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¿½åŠ 
    const pdfStyle = document.createElement('style');
    pdfStyle.id = 'pdf-export-styles';
    pdfStyle.textContent = `
            @media print {
                /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚„ã‚µã‚¤ãƒ‰ãƒãƒ¼ã‚’éè¡¨ç¤º */
                .main-toolbar,
                .toc-panel,
                .search-panel,
                .toc-floating-button {
                    display: none !important;
                }
                
                /* ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒãƒ¼ã‚¸ãƒ³ã‚’èª¿æ•´ */
                body {
                    margin: 0 !important;
                    padding: 20px !important;
                    font-size: 12pt !important;
                    line-height: 1.4 !important;
                    color: #000 !important;
                    background: #fff !important;
                }
                
                #markdown-content {
                    margin-left: 0 !important;
                    margin-right: 0 !important;
                    max-width: none !important;
                }
                
                /* è¦‹å‡ºã—ã®æ”¹ãƒšãƒ¼ã‚¸åˆ¶å¾¡ */
                h1, h2, h3, h4, h5, h6 {
                    page-break-after: avoid;
                    page-break-inside: avoid;
                }
                
                /* ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¨ãƒ†ãƒ¼ãƒ–ãƒ«ã®æ”¹ãƒšãƒ¼ã‚¸åˆ¶å¾¡ */
                pre, blockquote, table {
                    page-break-inside: avoid;
                }
                
                /* Mermaidå›³ã®èª¿æ•´ */
                .mermaid {
                    page-break-inside: avoid;
                    max-width: 100% !important;
                }
                
                /* ãƒªãƒ³ã‚¯ã®å°åˆ·æ™‚è¡¨ç¤º */
                a {
                    text-decoration: none !important;
                    color: inherit !important;
                }
                
                /* å¤–éƒ¨ãƒªãƒ³ã‚¯ã®URLè¡¨ç¤º */
                a[href^="http"]:after {
                    content: " (" attr(href) ")";
                    font-size: 9pt;
                    color: #666;
                }
            }
        `;
    document.head.appendChild(pdfStyle);
  }

  removePrintStyles() {
    const pdfStyle = document.getElementById('pdf-export-styles');
    if (pdfStyle) {
      pdfStyle.remove();
    }
  }

  showPDFGeneratingMessage() {
    // æ—¢å­˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
    this.removePDFMessages();

    const message = document.createElement('div');
    message.id = 'pdf-generating-message';
    message.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #cce7ff;
            border: 1px solid #99d6ff;
            color: #004085;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            font-size: 14px;
            max-width: 350px;
        `;
    message.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 18px; margin-right: 10px;">â³</span>
                <div>
                    <strong>PDFç”Ÿæˆä¸­...</strong><br>
                    <small>ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚</small>
                </div>
            </div>
        `;
    document.body.appendChild(message);
  }

  showPDFDirectSuccessMessage() {
    // æ—¢å­˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
    this.removePDFMessages();

    const message = document.createElement('div');
    message.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            font-size: 14px;
            max-width: 350px;
        `;
    message.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 18px; margin-right: 10px;">âœ…</span>
                <div>
                    <strong>PDFç”Ÿæˆå®Œäº†ï¼</strong><br>
                    <small>PDFãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚</small>
                </div>
            </div>
        `;
    document.body.appendChild(message);

    // Auto-hide after 3 seconds
    setTimeout(() => {
      if (message.parentNode) {
        message.parentNode.removeChild(message);
      }
    }, 3000);
  }

  showPDFSuccessMessage() {
    // æ—¢å­˜ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‰Šé™¤
    this.removePDFMessages();

    const message = document.createElement('div');
    message.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            font-size: 14px;
            max-width: 350px;
        `;
    message.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 18px; margin-right: 10px;">ğŸ“‹</span>
                <div>
                    <strong>PDFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</strong><br>
                    <small>å°åˆ·ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã§ã€ŒPDFã«ä¿å­˜ã€ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</small>
                </div>
            </div>
        `;
    document.body.appendChild(message);

    // Auto-hide after 5 seconds
    setTimeout(() => {
      if (message.parentNode) {
        message.parentNode.removeChild(message);
      }
    }, 5000);
  }

  removePDFMessages() {
    const existingMessages = document.querySelectorAll(
      '#pdf-generating-message'
    );
    existingMessages.forEach(msg => msg.remove());
  }

  showPDFErrorMessage() {
    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
    const existingToast = document.querySelector('.pdf-error-toast');
    if (existingToast) {
      existingToast.remove();
    }

    // å°åˆ·ã‚¨ãƒ©ãƒ¼ã¨å®Œå…¨ã«åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«
    const toast = document.createElement('div');
    toast.className = 'pdf-error-toast';
    toast.innerHTML = `
            <div class="toast-content">
                <div class="toast-icon">âš ï¸</div>
                <div class="toast-message">
                    <strong>PDFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã«ã¤ã„ã¦</strong><br>
                    ã“ã®ç’°å¢ƒã§ã¯PDFã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚<br>
                    ãƒ–ãƒ©ã‚¦ã‚¶ã®å°åˆ·æ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
                </div>
                <button class="toast-close">Ã—</button>
            </div>
        `;

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š - å°åˆ·ã‚¨ãƒ©ãƒ¼ã¨å®Œå…¨ã«åŒã˜
    toast.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            max-width: 350px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            animation: slideInRight 0.3s ease;
        `;

    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const content = toast.querySelector('.toast-content');
    content.style.cssText = `
            display: flex;
            align-items: flex-start;
            padding: 16px;
            gap: 12px;
        `;

    // ã‚¢ã‚¤ã‚³ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const icon = toast.querySelector('.toast-icon');
    icon.style.cssText = `
            font-size: 20px;
            flex-shrink: 0;
        `;

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const message = toast.querySelector('.toast-message');
    message.style.cssText = `
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            color: #856404;
        `;

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const closeBtn = toast.querySelector('.toast-close');
    closeBtn.style.cssText = `
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #856404;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            flex-shrink: 0;
        `;

    // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
    if (!document.querySelector('#toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                .toast-close:hover {
                    background: rgba(0,0,0,0.1) !important;
                }
            `;
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    closeBtn.addEventListener('click', () => {
      toast.remove();
    });

    // ãƒ›ãƒãƒ¼åŠ¹æœ
    closeBtn.addEventListener('mouseenter', () => {
      closeBtn.style.backgroundColor = 'rgba(0,0,0,0.1)';
    });
    closeBtn.addEventListener('mouseleave', () => {
      closeBtn.style.backgroundColor = 'transparent';
    });

    // 5ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
    }, 5000);
  }

  generateCompleteHTML() {
    // ç¾åœ¨ã®ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
    const markdownContent = document.getElementById('markdown-content');
    if (!markdownContent) {
      throw new Error('Markdown content not found');
    }

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const title = document.title || 'Markdown Document';
    const currentURL = location.href;
    const timestamp = new Date().toLocaleString();

    // ã™ã¹ã¦ã®CSSã‚’åé›†
    const allCSS = this.collectAllCSS();

    // å®Œå…¨ãªHTMLã‚’ç”Ÿæˆ
    const completeHTML = `<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${title}</title>
    <meta name="generator" content="Markdown Viewer with Mermaid Extension">
    <meta name="exported-from" content="${currentURL}">
    <meta name="export-date" content="${timestamp}">
    <style>
${allCSS}
        
        /* Export-specific styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            color: #24292e;
            background-color: #ffffff;
        }
        
        .export-header {
            border-bottom: 2px solid #e1e4e8;
            margin-bottom: 2em;
            padding-bottom: 1em;
            text-align: center;
            color: #586069;
        }
        
        .export-footer {
            border-top: 1px solid #e1e4e8;
            margin-top: 3em;
            padding-top: 1em;
            text-align: center;
            font-size: 0.9em;
            color: #586069;
        }
        
        @media print {
            .export-header, .export-footer {
                break-inside: avoid;
            }
        }
    </style>
</head>
<body>
    <div class="export-header">
        <h1>${title}</h1>
        <p>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ—¥æ™‚: ${timestamp}</p>
        <p>å…ƒURL: <a href="${currentURL}">${currentURL}</a></p>
    </div>
    
    <div class="markdown-content">
        ${markdownContent.innerHTML}
    </div>
    
    <div class="export-footer">
        <p>Generated by <strong>Markdown Viewer with Mermaid Extension</strong></p>
        <p>Exported from: ${currentURL}</p>
    </div>
</body>
</html>`;

    return completeHTML;
  }

  collectAllCSS() {
    let allCSS = '';

    // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³ã‚¹ã‚¿ã‚¤ãƒ«ã‹ã‚‰åé›†
    const styleElements = document.querySelectorAll('style');
    styleElements.forEach(style => {
      if (style.textContent) {
        allCSS += style.textContent + '\n';
      }
    });

    // ãƒªãƒ³ã‚¯ã•ã‚ŒãŸã‚¹ã‚¿ã‚¤ãƒ«ã‚·ãƒ¼ãƒˆã‹ã‚‰åé›†ï¼ˆChromeæ‹¡å¼µæ©Ÿèƒ½ã®ã‚‚ã®ï¼‰
    const linkElements = document.querySelectorAll('link[rel="stylesheet"]');
    linkElements.forEach(link => {
      if (link.href && link.href.includes('chrome-extension://')) {
        // Chromeæ‹¡å¼µæ©Ÿèƒ½ã®CSSã¯ç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ããªã„ãŸã‚ã€
        // ä¸»è¦ãªã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ‰‹å‹•ã§è¿½åŠ 
        allCSS += this.getEssentialCSS();
      }
    });

    return allCSS;
  }

  getEssentialCSS() {
    return `
        /* Essential Markdown styles */
        h1, h2, h3, h4, h5, h6 {
            margin-top: 2em;
            margin-bottom: 1em;
            font-weight: 600;
            line-height: 1.25;
        }
        
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        h4 { font-size: 1em; }
        h5 { font-size: 0.875em; }
        h6 { font-size: 0.85em; color: #6a737d; }
        
        p { margin-bottom: 16px; }
        
        code {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            margin: 0;
            padding: 0.2em 0.4em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }
        
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        pre code {
            background-color: transparent;
            border: 0;
            display: inline;
            line-height: inherit;
            margin: 0;
            max-width: auto;
            overflow: visible;
            padding: 0;
            word-wrap: normal;
        }
        
        blockquote {
            border-left: 0.25em solid #dfe2e5;
            color: #6a737d;
            padding: 0 1em;
            margin: 0 0 16px 0;
        }
        
        ul, ol {
            padding-left: 2em;
            margin-bottom: 16px;
        }
        
        li + li {
            margin-top: 0.25em;
        }
        
        table {
            border-collapse: collapse;
            border-spacing: 0;
            display: block;
            width: max-content;
            max-width: 100%;
            overflow: auto;
            margin-bottom: 16px;
        }
        
        table th, table td {
            border: 1px solid #dfe2e5;
            padding: 6px 13px;
        }
        
        table th {
            background-color: #f6f8fa;
            font-weight: 600;
        }
        
        table tr {
            background-color: #fff;
            border-top: 1px solid #c6cbd1;
        }
        
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        
        a {
            color: #0366d6;
            text-decoration: none;
        }
        
        a:hover {
            text-decoration: underline;
        }
        
        .mermaid {
            text-align: center;
            margin: 1em 0;
        }
        `;
  }

  downloadHTMLFile(htmlContent) {
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `markdown-export-${timestamp}.html`;

    const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
    const url = URL.createObjectURL(blob);

    const downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = filename;
    downloadLink.style.display = 'none';

    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);

    // Clean up
    setTimeout(() => URL.revokeObjectURL(url), TIMEOUTS.VERY_LONG_DELAY);
  }

  showExportSuccessMessage() {
    const message = document.createElement('div');
    message.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10000;
            font-size: 14px;
            max-width: 350px;
        `;
    message.innerHTML = `
            <div style="display: flex; align-items: center;">
                <span style="font-size: 18px; margin-right: 10px;">âœ…</span>
                <div>
                    <strong>HTMLã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆå®Œäº†ï¼</strong><br>
                    <small>ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚</small>
                </div>
            </div>
        `;
    document.body.appendChild(message);

    // Auto-hide after 3 seconds
    setTimeout(() => {
      if (message.parentNode) {
        message.parentNode.removeChild(message);
      }
    }, 3000);
  }

  showExportErrorMessage() {
    // æ—¢å­˜ã®ãƒˆãƒ¼ã‚¹ãƒˆãŒã‚ã‚Œã°å‰Šé™¤
    const existingToast = document.querySelector('.export-error-toast');
    if (existingToast) {
      existingToast.remove();
    }

    // å°åˆ·ã‚¨ãƒ©ãƒ¼ã¨å®Œå…¨ã«åŒã˜ã‚¹ã‚¿ã‚¤ãƒ«
    const toast = document.createElement('div');
    toast.className = 'export-error-toast';
    toast.innerHTML = `
            <div class="toast-content">
                <div class="toast-icon">âš ï¸</div>
                <div class="toast-message">
                    <strong>ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã«ã¤ã„ã¦</strong><br>
                    ã“ã®ç’°å¢ƒã§ã¯ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚<br>
                    ãƒ–ãƒ©ã‚¦ã‚¶ã®å°åˆ·æ©Ÿèƒ½ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
                </div>
                <button class="toast-close">Ã—</button>
            </div>
        `;

    // ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š - å°åˆ·ã‚¨ãƒ©ãƒ¼ã¨å®Œå…¨ã«åŒã˜
    toast.style.cssText = `
            position: fixed;
            top: 80px;
            right: 20px;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 10010;
            max-width: 350px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            animation: slideInRight 0.3s ease;
        `;

    // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const content = toast.querySelector('.toast-content');
    content.style.cssText = `
            display: flex;
            align-items: flex-start;
            padding: 16px;
            gap: 12px;
        `;

    // ã‚¢ã‚¤ã‚³ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const icon = toast.querySelector('.toast-icon');
    icon.style.cssText = `
            font-size: 20px;
            flex-shrink: 0;
        `;

    // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const message = toast.querySelector('.toast-message');
    message.style.cssText = `
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            color: #856404;
        `;

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«
    const closeBtn = toast.querySelector('.toast-close');
    closeBtn.style.cssText = `
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #856404;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            flex-shrink: 0;
        `;

    // CSSã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ 
    if (!document.querySelector('#toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.textContent = `
                @keyframes slideInRight {
                    from {
                        transform: translateX(100%);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                .toast-close:hover {
                    background: rgba(0,0,0,0.1) !important;
                }
            `;
      document.head.appendChild(style);
    }

    document.body.appendChild(toast);

    // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
    closeBtn.addEventListener('click', () => {
      toast.remove();
    });

    // ãƒ›ãƒãƒ¼åŠ¹æœ
    closeBtn.addEventListener('mouseenter', () => {
      closeBtn.style.backgroundColor = 'rgba(0,0,0,0.1)';
    });
    closeBtn.addEventListener('mouseleave', () => {
      closeBtn.style.backgroundColor = 'transparent';
    });

    // 5ç§’å¾Œã«è‡ªå‹•ã§é–‰ã˜ã‚‹
    setTimeout(() => {
      if (toast.parentNode) {
        toast.remove();
      }
    }, 5000);
  }
}

// Ensure class is available globally
window.Toolbar = Toolbar;
