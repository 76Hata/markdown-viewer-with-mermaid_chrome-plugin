# Chrome拡張機能「Markdown Viewer with Mermaid」詳細設計書

## 1. Phase 1 機能詳細設計

### 1.1 目次自動生成機能

#### 1.1.1 クラス設計
```javascript
/**
 * 目次自動生成クラス
 */
class TOCGenerator {
    constructor(options = {}) {
        this.options = {
            maxDepth: 6,           // 最大見出しレベル
            minDepth: 1,           // 最小見出しレベル
            includeNumbers: true,   // 番号付きかどうか
            smoothScroll: true,     // スムーススクロール
            autoCollapse: false,    // 自動折りたたみ
            position: 'left',       // 表示位置 (left, right, top)
            width: '250px',         // パネル幅
            ...options
        };
        
        this.headings = [];         // 見出し要素配列
        this.tocElement = null;     // 目次DOM要素
        this.activeHeading = null;  // 現在アクティブな見出し
        this.observer = null;       // Intersection Observer
        
        this.init();
    }
    
    /**
     * 初期化処理
     */
    init() {
        this.extractHeadings();
        this.createTOCStructure();
        this.renderTOC();
        this.setupScrollSpy();
        this.bindEvents();
    }
    
    /**
     * 見出し要素の抽出
     */
    extractHeadings() {
        const container = document.querySelector('#markdown-content') || document.body;
        const selector = this.generateHeadingSelector();
        const headingElements = container.querySelectorAll(selector);
        
        this.headings = Array.from(headingElements).map((element, index) => {
            // 見出しにIDが無い場合は生成
            if (!element.id) {
                element.id = this.generateHeadingId(element.textContent, index);
            }
            
            return {
                id: element.id,
                level: parseInt(element.tagName.charAt(1)),
                text: element.textContent.trim(),
                element: element,
                children: [],
                parent: null,
                index: index
            };
        });
        
        this.buildHierarchy();
    }
    
    /**
     * 見出しセレクターの生成
     */
    generateHeadingSelector() {
        const levels = [];
        for (let i = this.options.minDepth; i <= this.options.maxDepth; i++) {
            levels.push(`h${i}`);
        }
        return levels.join(', ');
    }
    
    /**
     * 見出しIDの生成
     */
    generateHeadingId(text, index) {
        // 日本語・英語対応のスラッグ生成
        const slug = text
            .toLowerCase()
            .replace(/[^\w\s-]/g, '') // 特殊文字除去
            .replace(/\s+/g, '-')     // スペースをハイフンに
            .replace(/--+/g, '-')     // 連続ハイフンを単一に
            .trim();
        
        return slug || `heading-${index}`;
    }
    
    /**
     * 階層構造の構築
     */
    buildHierarchy() {
        const stack = [];
        
        this.headings.forEach(heading => {
            // 現在の見出しより深いレベルをスタックから削除
            while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
                stack.pop();
            }
            
            // 親要素の設定
            if (stack.length > 0) {
                const parent = stack[stack.length - 1];
                heading.parent = parent;
                parent.children.push(heading);
            }
            
            stack.push(heading);
        });
    }
    
    /**
     * 目次構造の作成
     */
    createTOCStructure() {
        this.tocElement = document.createElement('div');
        this.tocElement.className = 'toc-panel';
        this.tocElement.innerHTML = `
            <div class="toc-header">
                <h3>目次</h3>
                <button class="toc-toggle" title="折りたたみ">−</button>
            </div>
            <div class="toc-content">
                <nav class="toc-nav" role="navigation" aria-label="目次">
                    ${this.generateTOCHTML()}
                </nav>
            </div>
        `;
    }
    
    /**
     * 目次HTMLの生成
     */
    generateTOCHTML() {
        const rootHeadings = this.headings.filter(h => !h.parent);
        return `<ul class="toc-list">${this.generateHeadingHTML(rootHeadings)}</ul>`;
    }
    
    /**
     * 見出しHTMLの再帰生成
     */
    generateHeadingHTML(headings) {
        return headings.map(heading => {
            const hasChildren = heading.children.length > 0;
            const childrenHTML = hasChildren ? 
                `<ul class="toc-sublist">${this.generateHeadingHTML(heading.children)}</ul>` : '';
            
            const numberPrefix = this.options.includeNumbers ? 
                `<span class="toc-number">${this.getHeadingNumber(heading)}</span>` : '';
            
            return `
                <li class="toc-item" data-level="${heading.level}">
                    ${hasChildren ? '<button class="toc-expand" aria-expanded="true">▼</button>' : ''}
                    <a href="#${heading.id}" class="toc-link" data-heading-id="${heading.id}">
                        ${numberPrefix}
                        <span class="toc-text">${this.escapeHTML(heading.text)}</span>
                    </a>
                    ${childrenHTML}
                </li>
            `;
        }).join('');
    }
    
    /**
     * 見出し番号の取得
     */
    getHeadingNumber(heading) {
        // 階層に応じた番号生成ロジック
        const getNumber = (h, numbers = []) => {
            if (h.parent) {
                getNumber(h.parent, numbers);
            }
            const siblings = h.parent ? h.parent.children : this.headings.filter(h => !h.parent);
            numbers.push(siblings.indexOf(h) + 1);
            return numbers;
        };
        
        return getNumber(heading).join('.');
    }
    
    /**
     * HTMLエスケープ
     */
    escapeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    /**
     * 目次の描画
     */
    renderTOC() {
        // 既存の目次があれば削除
        const existingTOC = document.querySelector('.toc-panel');
        if (existingTOC) {
            existingTOC.remove();
        }
        
        // 目次をページに追加
        document.body.appendChild(this.tocElement);
        
        // 位置とスタイルの調整
        this.adjustTOCPosition();
        this.adjustContentMargin();
    }
    
    /**
     * 目次位置の調整
     */
    adjustTOCPosition() {
        const toc = this.tocElement;
        
        switch (this.options.position) {
            case 'left':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: ${this.options.width};
                    height: 100vh;
                    z-index: 1000;
                `;
                break;
            case 'right':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    right: 0;
                    width: ${this.options.width};
                    height: 100vh;
                    z-index: 1000;
                `;
                break;
            case 'top':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 200px;
                    z-index: 1000;
                `;
                break;
        }
    }
    
    /**
     * コンテンツマージンの調整
     */
    adjustContentMargin() {
        const content = document.querySelector('#markdown-content') || document.body;
        
        switch (this.options.position) {
            case 'left':
                content.style.marginLeft = `calc(${this.options.width} + 20px)`;
                break;
            case 'right':
                content.style.marginRight = `calc(${this.options.width} + 20px)`;
                break;
            case 'top':
                content.style.marginTop = '220px';
                break;
        }
    }
    
    /**
     * スクロールスパイの設定
     */
    setupScrollSpy() {
        const options = {
            root: null,
            rootMargin: '-20% 0px -70% 0px',
            threshold: 0
        };
        
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.setActiveHeading(entry.target.id);
                }
            });
        }, options);
        
        // 全ての見出し要素を監視
        this.headings.forEach(heading => {
            this.observer.observe(heading.element);
        });
    }
    
    /**
     * アクティブ見出しの設定
     */
    setActiveHeading(headingId) {
        // 前のアクティブ状態を削除
        const prevActive = this.tocElement.querySelector('.toc-link.active');
        if (prevActive) {
            prevActive.classList.remove('active');
        }
        
        // 新しいアクティブ状態を設定
        const newActive = this.tocElement.querySelector(`[data-heading-id="${headingId}"]`);
        if (newActive) {
            newActive.classList.add('active');
            this.activeHeading = headingId;
            
            // 目次内でのスクロール調整
            this.scrollTOCToActive(newActive);
        }
    }
    
    /**
     * 目次内のアクティブ項目へのスクロール
     */
    scrollTOCToActive(activeElement) {
        const tocContent = this.tocElement.querySelector('.toc-content');
        const elementTop = activeElement.offsetTop;
        const containerHeight = tocContent.clientHeight;
        const scrollTop = elementTop - containerHeight / 2;
        
        tocContent.scrollTo({
            top: scrollTop,
            behavior: 'smooth'
        });
    }
    
    /**
     * イベントバインディング
     */
    bindEvents() {
        // 目次リンククリック
        this.tocElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('toc-link')) {
                e.preventDefault();
                const headingId = e.target.dataset.headingId;
                this.scrollToHeading(headingId);
            }
            
            // 折りたたみボタン
            if (e.target.classList.contains('toc-expand')) {
                this.toggleSublist(e.target);
            }
            
            // 目次全体の折りたたみ
            if (e.target.classList.contains('toc-toggle')) {
                this.toggleTOC();
            }
        });
        
        // キーボードナビゲーション
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        this.navigateToHeading('prev');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.navigateToHeading('next');
                        break;
                }
            }
        });
    }
    
    /**
     * 見出しへのスムーススクロール
     */
    scrollToHeading(headingId) {
        const heading = document.getElementById(headingId);
        if (!heading) return;
        
        const offset = 20; // ヘッダーなどのオフセット
        const targetPosition = heading.offsetTop - offset;
        
        if (this.options.smoothScroll) {
            window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
            });
        } else {
            window.scrollTo(0, targetPosition);
        }
        
        // フォーカス設定（アクセシビリティ）
        heading.focus();
    }
    
    /**
     * サブリストの折りたたみ切り替え
     */
    toggleSublist(button) {
        const sublist = button.parentElement.querySelector('.toc-sublist');
        if (!sublist) return;
        
        const isExpanded = button.getAttribute('aria-expanded') === 'true';
        
        button.setAttribute('aria-expanded', !isExpanded);
        button.textContent = isExpanded ? '▶' : '▼';
        sublist.style.display = isExpanded ? 'none' : 'block';
    }
    
    /**
     * 目次全体の折りたたみ切り替え
     */
    toggleTOC() {
        const content = this.tocElement.querySelector('.toc-content');
        const toggle = this.tocElement.querySelector('.toc-toggle');
        const isCollapsed = content.style.display === 'none';
        
        content.style.display = isCollapsed ? 'block' : 'none';
        toggle.textContent = isCollapsed ? '−' : '+';
        
        // 幅の調整
        if (!isCollapsed) {
            this.tocElement.style.width = '40px';
        } else {
            this.tocElement.style.width = this.options.width;
        }
    }
    
    /**
     * キーボードナビゲーション
     */
    navigateToHeading(direction) {
        if (!this.activeHeading) return;
        
        const currentIndex = this.headings.findIndex(h => h.id === this.activeHeading);
        if (currentIndex === -1) return;
        
        let targetIndex;
        if (direction === 'prev') {
            targetIndex = Math.max(0, currentIndex - 1);
        } else {
            targetIndex = Math.min(this.headings.length - 1, currentIndex + 1);
        }
        
        const targetHeading = this.headings[targetIndex];
        this.scrollToHeading(targetHeading.id);
    }
    
    /**
     * 破棄処理
     */
    destroy() {
        if (this.observer) {
            this.observer.disconnect();
        }
        
        if (this.tocElement) {
            this.tocElement.remove();
        }
        
        // コンテンツマージンのリセット
        const content = document.querySelector('#markdown-content') || document.body;
        content.style.marginLeft = '';
        content.style.marginRight = '';
        content.style.marginTop = '';
    }
}
```

#### 1.1.2 CSS設計
```css
/* 目次パネルのスタイル */
.toc-panel {
    background: var(--toc-bg-color, #f8f9fa);
    border-right: 1px solid var(--toc-border-color, #e1e4e8);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    overflow-y: auto;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
}

.toc-header {
    padding: 15px;
    border-bottom: 1px solid var(--toc-border-color, #e1e4e8);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--toc-header-bg, #ffffff);
}

.toc-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: var(--toc-text-color, #24292e);
}

.toc-toggle {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
    color: var(--toc-text-color, #586069);
}

.toc-toggle:hover {
    background: var(--toc-hover-bg, #f1f3f4);
}

.toc-content {
    padding: 10px 0;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
}

.toc-nav {
    padding: 0 15px;
}

.toc-list {
    list-style: none;
    margin: 0;
    padding: 0;
}

.toc-sublist {
    list-style: none;
    margin: 5px 0 0 0;
    padding-left: 20px;
}

.toc-item {
    margin: 2px 0;
    position: relative;
}

.toc-expand {
    position: absolute;
    left: -15px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 10px;
    cursor: pointer;
    padding: 2px;
    color: var(--toc-text-color, #586069);
}

.toc-link {
    display: flex;
    align-items: center;
    padding: 5px 8px;
    text-decoration: none;
    color: var(--toc-link-color, #0366d6);
    border-radius: 3px;
    transition: all 0.2s ease;
    line-height: 1.4;
}

.toc-link:hover {
    background: var(--toc-hover-bg, #f1f3f4);
    text-decoration: none;
}

.toc-link.active {
    background: var(--toc-active-bg, #0366d6);
    color: var(--toc-active-color, #ffffff);
    font-weight: 500;
}

.toc-number {
    margin-right: 8px;
    font-size: 12px;
    color: var(--toc-number-color, #586069);
    min-width: 20px;
}

.toc-link.active .toc-number {
    color: var(--toc-active-color, #ffffff);
}

.toc-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* レベル別のインデント */
.toc-item[data-level="1"] .toc-link {
    font-weight: 600;
}

.toc-item[data-level="2"] .toc-link {
    font-size: 13px;
}

.toc-item[data-level="3"] .toc-link {
    font-size: 12px;
    opacity: 0.9;
}

.toc-item[data-level="4"],
.toc-item[data-level="5"],
.toc-item[data-level="6"] {
    font-size: 11px;
    opacity: 0.8;
}

/* ダークテーマ対応 */
[data-theme="dark"] .toc-panel {
    --toc-bg-color: #1a1a1a;
    --toc-border-color: #30363d;
    --toc-header-bg: #21262d;
    --toc-text-color: #c9d1d9;
    --toc-link-color: #58a6ff;
    --toc-hover-bg: #30363d;
    --toc-active-bg: #0969da;
    --toc-active-color: #ffffff;
    --toc-number-color: #8b949e;
}

/* レスポンシブ対応 */
@media (max-width: 768px) {
    .toc-panel {
        transform: translateX(-100%);
        transition: transform 0.3s ease;
    }
    
    .toc-panel.mobile-open {
        transform: translateX(0);
    }
    
    .toc-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
    }
    
    .toc-overlay.active {
        display: block;
    }
}
```

### 1.2 テーマシステム詳細設計

#### 1.2.1 ThemeManagerクラス
```javascript
/**
 * テーマ管理クラス
 */
class ThemeManager {
    constructor() {
        this.themes = new Map();
        this.currentTheme = 'light';
        this.customCSS = '';
        this.systemThemeQuery = null;
        this.observers = new Set();
        
        this.init();
    }
    
    /**
     * 初期化処理
     */
    async init() {
        await this.loadSettings();
        this.registerDefaultThemes();
        this.setupSystemThemeDetection();
        this.applyTheme(this.currentTheme);
    }
    
    /**
     * 設定の読み込み
     */
    async loadSettings() {
        try {
            const result = await chrome.storage.sync.get(['theme', 'customCSS']);
            this.currentTheme = result.theme || 'light';
            this.customCSS = result.customCSS || '';
        } catch (error) {
            console.warn('Failed to load theme settings:', error);
        }
    }
    
    /**
     * デフォルトテーマの登録
     */
    registerDefaultThemes() {
        // ライトテーマ
        this.registerTheme('light', {
            name: 'Light',
            variables: {
                '--bg-color': '#ffffff',
                '--text-color': '#24292e',
                '--heading-color': '#1f2328',
                '--link-color': '#0969da',
                '--border-color': '#d1d9e0',
                '--code-bg': '#f6f8fa',
                '--blockquote-border': '#d1d9e0',
                '--table-border': '#d1d9e0',
                '--table-header-bg': '#f6f8fa'
            },
            mermaidTheme: 'default'
        });
        
        // ダークテーマ
        this.registerTheme('dark', {
            name: 'Dark',
            variables: {
                '--bg-color': '#0d1117',
                '--text-color': '#e6edf3',
                '--heading-color': '#f0f6fc',
                '--link-color': '#2f81f7',
                '--border-color': '#30363d',
                '--code-bg': '#161b22',
                '--blockquote-border': '#30363d',
                '--table-border': '#30363d',
                '--table-header-bg': '#161b22'
            },
            mermaidTheme: 'dark'
        });
        

    }
    
    /**
     * テーマの登録
     */
    registerTheme(name, config) {
        this.themes.set(name, {
            name: config.name || name,
            variables: config.variables || {},
            mermaidTheme: config.mermaidTheme || 'default',
            customCSS: config.customCSS || '',
            ...config
        });
    }
    
    /**
     * システムテーマ検出の設定
     */
    setupSystemThemeDetection() {
        this.systemThemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
        this.systemThemeQuery.addEventListener('change', (e) => {
            if (this.currentTheme === 'auto') {
                this.applyTheme('auto');
            }
        });
    }
    
    /**
     * テーマの適用
     */
    async applyTheme(themeName) {
        let actualTheme = themeName;
        
        // 自動テーマの場合はシステム設定に従う
        if (themeName === 'auto') {
            actualTheme = this.detectSystemTheme();
        }
        
        const theme = this.themes.get(actualTheme);
        if (!theme) {
            console.warn(`Theme "${actualTheme}" not found`);
            return;
        }
        
        // CSS変数の適用
        this.applyCSSVariables(theme.variables);
        
        // カスタムCSSの適用
        this.applyCustomCSS(theme.customCSS);
        
        // Mermaidテーマの適用
        await this.applyMermaidTheme(theme.mermaidTheme);
        
        // data-theme属性の設定
        document.documentElement.setAttribute('data-theme', actualTheme);
        
        // 現在のテーマを保存
        this.currentTheme = themeName;
        await this.saveSettings();
        
        // オブザーバーに通知
        this.notifyObservers('themeChanged', { theme: actualTheme, config: theme });
    }
    
    /**
     * CSS変数の適用
     */
    applyCSSVariables(variables) {
        const root = document.documentElement;
        
        Object.entries(variables).forEach(([property, value]) => {
            root.style.setProperty(property, value);
        });
    }
    
    /**
     * カスタムCSSの適用
     */
    applyCustomCSS(css) {
        // 既存のカスタムCSSを削除
        const existingStyle = document.getElementById('theme-custom-css');
        if (existingStyle) {
            existingStyle.remove();
        }
        
        // 新しいカスタムCSSを追加
        if (css) {
            const style = document.createElement('style');
            style.id = 'theme-custom-css';
            style.textContent = css;
            document.head.appendChild(style);
        }
    }
    
    /**
     * Mermaidテーマの適用
     */
    async applyMermaidTheme(mermaidTheme) {
        if (typeof mermaid !== 'undefined') {
            // Mermaidの再初期化
            mermaid.initialize({
                startOnLoad: false,
                theme: mermaidTheme,
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                }
            });
            
            // 既存のMermaid図を再描画
            await this.rerenderMermaidDiagrams();
        }
    }
    
    /**
     * Mermaid図の再描画
     */
    async rerenderMermaidDiagrams() {
        const mermaidElements = document.querySelectorAll('.mermaid');
        
        for (const element of mermaidElements) {
            try {
                // 元のコードを取得（data属性に保存されている想定）
                const originalCode = element.dataset.mermaidCode || element.textContent;
                
                if (originalCode) {
                    const { svg } = await mermaid.render(`mermaid-${Date.now()}`, originalCode);
                    element.innerHTML = svg;
                }
            } catch (error) {
                console.error('Failed to re-render mermaid diagram:', error);
            }
        }
    }
    
    /**
     * システムテーマの検出
     */
    detectSystemTheme() {
        return this.systemThemeQuery?.matches ? 'dark' : 'light';
    }
    
    /**
     * 利用可能なテーマ一覧の取得
     */
    getAvailableThemes() {
        return Array.from(this.themes.entries()).map(([key, theme]) => ({
            key,
            name: theme.name,
            preview: this.generateThemePreview(theme)
        }));
    }
    
    /**
     * テーマプレビューの生成
     */
    generateThemePreview(theme) {
        return {
            backgroundColor: theme.variables['--bg-color'],
            textColor: theme.variables['--text-color'],
            headingColor: theme.variables['--heading-color'],
            linkColor: theme.variables['--link-color']
        };
    }
    
    /**
     * カスタムCSSの設定
     */
    async setCustomCSS(css) {
        this.customCSS = css;
        this.applyCustomCSS(css);
        await this.saveSettings();
    }
    
    /**
     * 設定の保存
     */
    async saveSettings() {
        try {
            await chrome.storage.sync.set({
                theme: this.currentTheme,
                customCSS: this.customCSS
            });
        } catch (error) {
            console.error('Failed to save theme settings:', error);
        }
    }
    
    /**
     * オブザーバーの追加
     */
    addObserver(callback) {
        this.observers.add(callback);
    }
    
    /**
     * オブザーバーの削除
     */
    removeObserver(callback) {
        this.observers.delete(callback);
    }
    
    /**
     * オブザーバーへの通知
     */
    notifyObservers(event, data) {
        this.observers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('Observer callback error:', error);
            }
        });
    }
    
    /**
     * 破棄処理
     */
    destroy() {
        if (this.systemThemeQuery) {
            this.systemThemeQuery.removeEventListener('change', this.handleSystemThemeChange);
        }
        
        this.observers.clear();
    }
}
```

#### 1.2.2 テーマセレクターUI
```javascript
/**
 * テーマ選択UIコンポーネント
 */
class ThemeSelector {
    constructor(container, themeManager) {
        this.container = container;
        this.themeManager = themeManager;
        this.isOpen = false;
        
        this.render();
        this.bindEvents();
    }
    
    render() {
        const themes = this.themeManager.getAvailableThemes();
        const currentTheme = this.themeManager.currentTheme;
        
        this.container.innerHTML = `
            <div class="theme-selector">
                <button class="theme-selector-button" title="テーマを選択">
                    🎨 <span class="theme-name">${this.getThemeName(currentTheme)}</span>
                </button>
                <div class="theme-dropdown" style="display: none;">
                    <div class="theme-options">
                        ${themes.map(theme => `
                            <div class="theme-option ${theme.key === currentTheme ? 'active' : ''}" 
                                 data-theme="${theme.key}">
                                <div class="theme-preview" style="
                                    background: ${theme.preview.backgroundColor};
                                    color: ${theme.preview.textColor};
                                    border: 1px solid ${theme.preview.linkColor};
                                ">
                                    <div class="preview-text">Aa</div>
                                </div>
                                <span class="theme-label">${theme.name}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div class="theme-actions">
                        <button class="custom-css-button">カスタムCSS</button>
                        <button class="auto-theme-button ${currentTheme === 'auto' ? 'active' : ''}">
                            自動切り替え
                        </button>
                    </div>
                </div>
            </div>
        `;
    }
    
    getThemeName(themeKey) {
        if (themeKey === 'auto') return '自動';
        const theme = this.themeManager.themes.get(themeKey);
        return theme ? theme.name : themeKey;
    }
    
    bindEvents() {
        const button = this.container.querySelector('.theme-selector-button');
        const dropdown = this.container.querySelector('.theme-dropdown');
        
        // ドロップダウンの開閉
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown();
        });
        
        // テーマ選択
        dropdown.addEventListener('click', (e) => {
            if (e.target.closest('.theme-option')) {
                const themeKey = e.target.closest('.theme-option').dataset.theme;
                this.selectTheme(themeKey);
            }
            
            if (e.target.classList.contains('auto-theme-button')) {
                this.toggleAutoTheme();
            }
            
            if (e.target.classList.contains('custom-css-button')) {
                this.openCustomCSSEditor();
            }
        });
        
        // 外部クリックで閉じる
        document.addEventListener('click', () => {
            this.closeDropdown();
        });
    }
    
    toggleDropdown() {
        this.isOpen = !this.isOpen;
        const dropdown = this.container.querySelector('.theme-dropdown');
        dropdown.style.display = this.isOpen ? 'block' : 'none';
    }
    
    closeDropdown() {
        this.isOpen = false;
        const dropdown = this.container.querySelector('.theme-dropdown');
        dropdown.style.display = 'none';
    }
    
    async selectTheme(themeKey) {
        await this.themeManager.applyTheme(themeKey);
        this.updateUI();
        this.closeDropdown();
    }
    
    toggleAutoTheme() {
        const currentTheme = this.themeManager.currentTheme;
        const newTheme = currentTheme === 'auto' ? 'light' : 'auto';
        this.selectTheme(newTheme);
    }
    
    updateUI() {
        const currentTheme = this.themeManager.currentTheme;
        
        // ボタンテキストの更新
        const themeName = this.container.querySelector('.theme-name');
        themeName.textContent = this.getThemeName(currentTheme);
        
        // アクティブ状態の更新
        this.container.querySelectorAll('.theme-option').forEach(option => {
            option.classList.toggle('active', option.dataset.theme === currentTheme);
        });
        
        // 自動切り替えボタンの状態更新
        const autoButton = this.container.querySelector('.auto-theme-button');
        autoButton.classList.toggle('active', currentTheme === 'auto');
    }
    
    openCustomCSSEditor() {
        // カスタムCSSエディターを開く（モーダルまたは別ページ）
        const modal = this.createCustomCSSModal();
        document.body.appendChild(modal);
    }
    
    createCustomCSSModal() {
        const modal = document.createElement('div');
        modal.className = 'custom-css-modal';
        modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>カスタムCSS</h3>
                        <button class="modal-close">×</button>
                    </div>
                    <div class="modal-body">
                        <textarea class="custom-css-editor" placeholder="/* カスタムCSSを入力してください */\n\nbody {\n    /* スタイルを記述 */\n}">${this.themeManager.customCSS}</textarea>
                    </div>
                    <div class="modal-footer">
                        <button class="css-apply-button">適用</button>
                        <button class="css-reset-button">リセット</button>
                        <button class="css-cancel-button">キャンセル</button>
                    </div>
                </div>
            </div>
        `;
        
        // モーダルイベント
        modal.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay') || 
                e.target.classList.contains('modal-close') ||
                e.target.classList.contains('css-cancel-button')) {
                modal.remove();
            }
            
            if (e.target.classList.contains('css-apply-button')) {
                const css = modal.querySelector('.custom-css-editor').value;
                this.themeManager.setCustomCSS(css);
                modal.remove();
            }
            
            if (e.target.classList.contains('css-reset-button')) {
                modal.querySelector('.custom-css-editor').value = '';
            }
        });
        
        return modal;
    }
}
```

### 1.3 Markdown編集機能詳細設計

#### 1.3.1 MarkdownEditorクラス
```javascript
/**
 * Markdown編集機能クラス
 */
class MarkdownEditor {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            autoSave: false,
            saveInterval: 30000,
            backupEnabled: true,
            confirmBeforeSave: true,
            ...options
        };
        
        this.isEditing = false;
        this.originalContent = '';
        this.currentContent = '';
        this.isDirty = false;
        this.autoSaveTimer = null;
        this.editorElement = null;
        this.previewElement = null;
        
        this.init();
    }
    
    /**
     * 初期化処理
     */
    init() {
        this.createEditorUI();
        this.bindEvents();
        this.setupAutoSave();
    }
    
    /**
     * エディターUIの作成
     */
    createEditorUI() {
        this.editorElement = document.createElement('div');
        this.editorElement.className = 'markdown-editor';
        this.editorElement.innerHTML = `
            <div class="editor-toolbar">
                <button class="editor-btn" data-action="save" title="保存">💾</button>
                <button class="editor-btn" data-action="save-as" title="別名保存">📄</button>
                <button class="editor-btn" data-action="preview" title="プレビュー">👁️</button>
                <button class="editor-btn" data-action="close" title="閉じる">✕</button>
                <span class="editor-status"></span>
            </div>
            <div class="editor-content">
                <div class="editor-pane">
                    <textarea class="editor-textarea" placeholder="Markdownを入力してください..."></textarea>
                </div>
                <div class="preview-pane" style="display: none;">
                    <div class="preview-content"></div>
                </div>
            </div>
        `;
        
        this.container.appendChild(this.editorElement);
        this.textarea = this.editorElement.querySelector('.editor-textarea');
        this.previewElement = this.editorElement.querySelector('.preview-content');
    }
    
    /**
     * 編集モードを開始
     */
    startEditing(content = '') {
        this.originalContent = content;
        this.currentContent = content;
        this.textarea.value = content;
        this.isEditing = true;
        this.isDirty = false;
        
        this.editorElement.style.display = 'block';
        this.textarea.focus();
        
        this.updateStatus('編集中');
    }
    
    /**
     * 保存処理
     */
    async save(saveAs = false) {
        try {
            const content = this.textarea.value;
            const fileManager = window.fileManager;
            
            if (!fileManager) {
                throw new Error('FileManager not available');
            }
            
            let result;
            if (saveAs) {
                result = await fileManager.saveAs(content);
            } else {
                result = await fileManager.save(content);
            }
            
            if (result.success) {
                this.originalContent = content;
                this.currentContent = content;
                this.isDirty = false;
                this.updateStatus('保存完了');
                
                // バックアップ作成
                if (this.options.backupEnabled) {
                    await fileManager.createBackup(content);
                }
            } else {
                throw new Error(result.error || '保存に失敗しました');
            }
            
        } catch (error) {
            console.error('Save error:', error);
            this.updateStatus('保存エラー: ' + error.message);
        }
    }
    
    /**
     * イベントバインディング
     */
    bindEvents() {
        // ツールバーボタン
        this.editorElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('editor-btn')) {
                const action = e.target.dataset.action;
                this.handleToolbarAction(action);
            }
        });
        
        // テキスト変更監視
        this.textarea.addEventListener('input', () => {
            this.currentContent = this.textarea.value;
            this.isDirty = this.currentContent !== this.originalContent;
            this.updateStatus(this.isDirty ? '未保存' : '保存済み');
        });
    }
    
    /**
     * ツールバーアクション処理
     */
    async handleToolbarAction(action) {
        switch (action) {
            case 'save':
                await this.save();
                break;
            case 'save-as':
                await this.save(true);
                break;
            case 'close':
                this.stopEditing();
                break;
        }
    }
    
    /**
     * ステータス更新
     */
    updateStatus(message) {
        const statusElement = this.editorElement.querySelector('.editor-status');
        statusElement.textContent = message;
    }
}
```

---

**作成日**: 2025年1月28日  
**バージョン**: 1.0  
**作成者**: Kiro AI Assistant
##
# 1.5 ファイル管理機能詳細設計

#### 1.5.1 FileManagerクラス
```javascript
/**
 * ファイル管理クラス
 */
class FileManager {
    constructor(options = {}) {
        this.options = {
            defaultSaveMode: 'overwrite',
            confirmBeforeSave: true,
            backupEnabled: true,
            backupCount: 5,
            ...options
        };
        
        this.currentFilePath = null;
        this.backups = [];
        
        this.init();
    }
    
    /**
     * 初期化処理
     */
    init() {
        this.loadBackups();
    }
    
    /**
     * ファイル保存（上書き）
     */
    async save(content) {
        try {
            if (!this.currentFilePath) {
                return await this.saveAs(content);
            }
            
            if (this.options.confirmBeforeSave) {
                if (!confirm('ファイルを上書き保存しますか？')) {
                    return { success: false, cancelled: true };
                }
            }
            
            // File System Access API を使用（Chrome 86+）
            if ('showSaveFilePicker' in window) {
                const fileHandle = await this.getFileHandle();
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                
                return { success: true, filePath: fileHandle.name };
            } else {
                // フォールバック: ダウンロードとして保存
                return this.downloadFile(content, this.currentFilePath);
            }
            
        } catch (error) {
            console.error('Save error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * 別名保存
     */
    async saveAs(content) {
        try {
            let fileName = 'document.md';
            
            // File System Access API を使用
            if ('showSaveFilePicker' in window) {
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Markdown files',
                        accept: { 'text/markdown': ['.md', '.markdown'] }
                    }]
                });
                
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                
                this.currentFilePath = fileHandle.name;
                return { success: true, filePath: fileHandle.name };
                
            } else {
                // フォールバック: ダウンロードとして保存
                fileName = prompt('ファイル名を入力してください:', fileName);
                if (!fileName) {
                    return { success: false, cancelled: true };
                }
                
                return this.downloadFile(content, fileName);
            }
            
        } catch (error) {
            console.error('SaveAs error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * ダウンロードとしてファイル保存
     */
    downloadFile(content, fileName) {
        try {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            return { success: true, filePath: fileName };
            
        } catch (error) {
            console.error('Download error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * バックアップ作成
     */
    async createBackup(content) {
        if (!this.options.backupEnabled) return;
        
        try {
            const backup = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                content: content,
                filePath: this.currentFilePath
            };
            
            this.backups.unshift(backup);
            
            // バックアップ数の制限
            if (this.backups.length > this.options.backupCount) {
                this.backups = this.backups.slice(0, this.options.backupCount);
            }
            
            // ローカルストレージに保存
            await this.saveBackups();
            
            return { success: true, backupId: backup.id };
            
        } catch (error) {
            console.error('Backup error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * バックアップ復元
     */
    async restoreBackup(backupId) {
        try {
            const backup = this.backups.find(b => b.id === backupId);
            if (!backup) {
                throw new Error('バックアップが見つかりません');
            }
            
            if (confirm('このバックアップを復元しますか？現在の内容は失われます。')) {
                return { success: true, content: backup.content };
            }
            
            return { success: false, cancelled: true };
            
        } catch (error) {
            console.error('Restore error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * Mermaidコードの更新
     */
    async updateMermaidCode(mermaidElement, newCode, saveAs = false) {
        try {
            // 現在のMarkdownコンテンツを取得
            const markdownContent = this.getCurrentMarkdownContent();
            
            // Mermaidコードを置換
            const updatedContent = this.replaceMermaidCode(markdownContent, mermaidElement, newCode);
            
            // 保存
            let result;
            if (saveAs) {
                result = await this.saveAs(updatedContent);
            } else {
                result = await this.save(updatedContent);
            }
            
            return result;
            
        } catch (error) {
            console.error('Update Mermaid error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * 現在のMarkdownコンテンツを取得
     */
    getCurrentMarkdownContent() {
        // 実装: 現在表示されているMarkdownの元コンテンツを取得
        // これは実際の実装では、元のファイル内容を保持する仕組みが必要
        return document.body.dataset.originalMarkdown || '';
    }
    
    /**
     * Mermaidコードの置換
     */
    replaceMermaidCode(markdownContent, mermaidElement, newCode) {
        // 実装: Markdownコンテンツ内の対応するMermaidブロックを新しいコードで置換
        const mermaidId = mermaidElement.id || mermaidElement.dataset.mermaidId;
        
        // 簡単な実装例（実際はより堅牢な実装が必要）
        const mermaidRegex = /```mermaid\n([\s\S]*?)\n```/g;
        let matchCount = 0;
        
        return markdownContent.replace(mermaidRegex, (match, code) => {
            matchCount++;
            if (matchCount === parseInt(mermaidId?.replace('mermaid-', '') || '1')) {
                return `\`\`\`mermaid\n${newCode}\n\`\`\``;
            }
            return match;
        });
    }
    
    /**
     * バックアップの保存
     */
    async saveBackups() {
        try {
            const backupsData = JSON.stringify(this.backups);
            localStorage.setItem('markdown-viewer-backups', backupsData);
        } catch (error) {
            console.error('Save backups error:', error);
        }
    }
    
    /**
     * バックアップの読み込み
     */
    loadBackups() {
        try {
            const backupsData = localStorage.getItem('markdown-viewer-backups');
            if (backupsData) {
                this.backups = JSON.parse(backupsData);
            }
        } catch (error) {
            console.error('Load backups error:', error);
            this.backups = [];
        }
    }
    
    /**
     * バックアップ一覧の取得
     */
    getBackups() {
        return this.backups.map(backup => ({
            id: backup.id,
            timestamp: backup.timestamp,
            filePath: backup.filePath,
            preview: backup.content.substring(0, 100) + '...'
        }));
    }
    
    /**
     * ファイルハンドルの取得
     */
    async getFileHandle() {
        // 実装: 現在のファイルハンドルを取得
        // File System Access API の実装詳細
        return this.currentFileHandle;
    }
    
    /**
     * 破棄処理
     */
    destroy() {
        this.saveBackups();
    }
}
```

#### 1.5.2 CSS設計（編集機能用）
```css
/* Markdown エディター */
.markdown-editor {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--bg-color, #ffffff);
    z-index: 2000;
    display: none;
}

.editor-toolbar {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    background: var(--toolbar-bg, #f6f8fa);
    border-bottom: 1px solid var(--border-color, #d1d9e0);
    gap: 10px;
}

.editor-btn {
    background: var(--button-bg, #ffffff);
    border: 1px solid var(--border-color, #d1d9e0);
    border-radius: 6px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.editor-btn:hover {
    background: var(--button-hover-bg, #f3f4f6);
}

.editor-status {
    margin-left: auto;
    font-size: 12px;
    color: var(--text-secondary, #656d76);
}

.editor-content {
    display: flex;
    height: calc(100vh - 60px);
}

.editor-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.editor-textarea {
    flex: 1;
    border: none;
    outline: none;
    padding: 20px;
    font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    background: var(--bg-color, #ffffff);
    color: var(--text-color, #24292e);
}

.preview-pane {
    flex: 1;
    border-left: 1px solid var(--border-color, #d1d9e0);
    overflow-y: auto;
}

.preview-content {
    padding: 20px;
}

/* Mermaid エディター */
.mermaid-editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-editor-modal {
    background: var(--bg-color, #ffffff);
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 90vw;
    height: 80vh;
    max-width: 1200px;
    display: flex;
    flex-direction: column;
}

.mermaid-editor-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color, #d1d9e0);
}

.mermaid-editor-header h3 {
    margin: 0;
    font-size: 18px;
    color: var(--text-color, #24292e);
}

.mermaid-editor-close {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
    color: var(--text-secondary, #656d76);
}

.mermaid-editor-close:hover {
    background: var(--button-hover-bg, #f3f4f6);
}

.mermaid-editor-content {
    flex: 1;
    display: flex;
    min-height: 0;
}

.mermaid-editor-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.mermaid-code-editor {
    flex: 1;
    border: none;
    outline: none;
    padding: 20px;
    font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    background: var(--code-bg, #f6f8fa);
    color: var(--text-color, #24292e);
}

.mermaid-preview-pane {
    flex: 1;
    border-left: 1px solid var(--border-color, #d1d9e0);
    overflow: auto;
    background: var(--bg-color, #ffffff);
}

.mermaid-preview {
    padding: 20px;
    text-align: center;
}

.mermaid-error {
    color: #d73a49;
    background: #ffeef0;
    padding: 15px;
    border-radius: 6px;
    border: 1px solid #fdb8c0;
}

.mermaid-editor-footer {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 15px 20px;
    border-top: 1px solid var(--border-color, #d1d9e0);
    background: var(--toolbar-bg, #f6f8fa);
}

.mermaid-save-btn,
.mermaid-save-as-btn,
.mermaid-cancel-btn {
    background: var(--button-bg, #ffffff);
    border: 1px solid var(--border-color, #d1d9e0);
    border-radius: 6px;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.mermaid-save-btn {
    background: var(--primary-color, #0969da);
    color: white;
    border-color: var(--primary-color, #0969da);
}

.mermaid-save-btn:hover {
    background: var(--primary-hover, #0860ca);
}

.mermaid-editor-status {
    margin-left: auto;
    font-size: 12px;
    color: var(--text-secondary, #656d76);
}

/* ダークテーマ対応 */
[data-theme="dark"] {
    --toolbar-bg: #21262d;
    --button-bg: #21262d;
    --button-hover-bg: #30363d;
    --primary-color: #2f81f7;
    --primary-hover: #1f6feb;
    --text-secondary: #8b949e;
}
```

---

**作成日**: 2025年1月28日  
**バージョン**: 1.0  
**作成者**: Kiro AI Assistant