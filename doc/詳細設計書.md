# Chromeæ‹¡å¼µæ©Ÿèƒ½ã€ŒMarkdown Viewer with Mermaidã€è©³ç´°è¨­è¨ˆæ›¸

## 1. Phase 1 æ©Ÿèƒ½è©³ç´°è¨­è¨ˆ

### 1.1 ç›®æ¬¡è‡ªå‹•ç”Ÿæˆæ©Ÿèƒ½

#### 1.1.1 ã‚¯ãƒ©ã‚¹è¨­è¨ˆ
```javascript
/**
 * ç›®æ¬¡è‡ªå‹•ç”Ÿæˆã‚¯ãƒ©ã‚¹
 */
class TOCGenerator {
    constructor(options = {}) {
        this.options = {
            maxDepth: 6,           // æœ€å¤§è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«
            minDepth: 1,           // æœ€å°è¦‹å‡ºã—ãƒ¬ãƒ™ãƒ«
            includeNumbers: true,   // ç•ªå·ä»˜ãã‹ã©ã†ã‹
            smoothScroll: true,     // ã‚¹ãƒ ãƒ¼ã‚¹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            autoCollapse: false,    // è‡ªå‹•æŠ˜ã‚ŠãŸãŸã¿
            position: 'left',       // è¡¨ç¤ºä½ç½® (left, right, top)
            width: '250px',         // ãƒ‘ãƒãƒ«å¹…
            ...options
        };
        
        this.headings = [];         // è¦‹å‡ºã—è¦ç´ é…åˆ—
        this.tocElement = null;     // ç›®æ¬¡DOMè¦ç´ 
        this.activeHeading = null;  // ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªè¦‹å‡ºã—
        this.observer = null;       // Intersection Observer
        
        this.init();
    }
    
    /**
     * åˆæœŸåŒ–å‡¦ç†
     */
    init() {
        this.extractHeadings();
        this.createTOCStructure();
        this.renderTOC();
        this.setupScrollSpy();
        this.bindEvents();
    }
    
    /**
     * è¦‹å‡ºã—è¦ç´ ã®æŠ½å‡º
     */
    extractHeadings() {
        const container = document.querySelector('#markdown-content') || document.body;
        const selector = this.generateHeadingSelector();
        const headingElements = container.querySelectorAll(selector);
        
        this.headings = Array.from(headingElements).map((element, index) => {
            // è¦‹å‡ºã—ã«IDãŒç„¡ã„å ´åˆã¯ç”Ÿæˆ
            if (!element.id) {
                element.id = this.generateHeadingId(element.textContent, index);
            }
            
            return {
                id: element.id,
                level: parseInt(element.tagName.charAt(1)),
                text: element.textContent.trim(),
                element: element,
                children: [],
                parent: null,
                index: index
            };
        });
        
        this.buildHierarchy();
    }
    
    /**
     * è¦‹å‡ºã—ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®ç”Ÿæˆ
     */
    generateHeadingSelector() {
        const levels = [];
        for (let i = this.options.minDepth; i <= this.options.maxDepth; i++) {
            levels.push(`h${i}`);
        }
        return levels.join(', ');
    }
    
    /**
     * è¦‹å‡ºã—IDã®ç”Ÿæˆ
     */
    generateHeadingId(text, index) {
        // æ—¥æœ¬èªãƒ»è‹±èªå¯¾å¿œã®ã‚¹ãƒ©ãƒƒã‚°ç”Ÿæˆ
        const slug = text
            .toLowerCase()
            .replace(/[^\w\s-]/g, '') // ç‰¹æ®Šæ–‡å­—é™¤å»
            .replace(/\s+/g, '-')     // ã‚¹ãƒšãƒ¼ã‚¹ã‚’ãƒã‚¤ãƒ•ãƒ³ã«
            .replace(/--+/g, '-')     // é€£ç¶šãƒã‚¤ãƒ•ãƒ³ã‚’å˜ä¸€ã«
            .trim();
        
        return slug || `heading-${index}`;
    }
    
    /**
     * éšå±¤æ§‹é€ ã®æ§‹ç¯‰
     */
    buildHierarchy() {
        const stack = [];
        
        this.headings.forEach(heading => {
            // ç¾åœ¨ã®è¦‹å‡ºã—ã‚ˆã‚Šæ·±ã„ãƒ¬ãƒ™ãƒ«ã‚’ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å‰Šé™¤
            while (stack.length > 0 && stack[stack.length - 1].level >= heading.level) {
                stack.pop();
            }
            
            // è¦ªè¦ç´ ã®è¨­å®š
            if (stack.length > 0) {
                const parent = stack[stack.length - 1];
                heading.parent = parent;
                parent.children.push(heading);
            }
            
            stack.push(heading);
        });
    }
    
    /**
     * ç›®æ¬¡æ§‹é€ ã®ä½œæˆ
     */
    createTOCStructure() {
        this.tocElement = document.createElement('div');
        this.tocElement.className = 'toc-panel';
        this.tocElement.innerHTML = `
            <div class="toc-header">
                <h3>ç›®æ¬¡</h3>
                <button class="toc-toggle" title="æŠ˜ã‚ŠãŸãŸã¿">âˆ’</button>
            </div>
            <div class="toc-content">
                <nav class="toc-nav" role="navigation" aria-label="ç›®æ¬¡">
                    ${this.generateTOCHTML()}
                </nav>
            </div>
        `;
    }
    
    /**
     * ç›®æ¬¡HTMLã®ç”Ÿæˆ
     */
    generateTOCHTML() {
        const rootHeadings = this.headings.filter(h => !h.parent);
        return `<ul class="toc-list">${this.generateHeadingHTML(rootHeadings)}</ul>`;
    }
    
    /**
     * è¦‹å‡ºã—HTMLã®å†å¸°ç”Ÿæˆ
     */
    generateHeadingHTML(headings) {
        return headings.map(heading => {
            const hasChildren = heading.children.length > 0;
            const childrenHTML = hasChildren ? 
                `<ul class="toc-sublist">${this.generateHeadingHTML(heading.children)}</ul>` : '';
            
            const numberPrefix = this.options.includeNumbers ? 
                `<span class="toc-number">${this.getHeadingNumber(heading)}</span>` : '';
            
            return `
                <li class="toc-item" data-level="${heading.level}">
                    ${hasChildren ? '<button class="toc-expand" aria-expanded="true">â–¼</button>' : ''}
                    <a href="#${heading.id}" class="toc-link" data-heading-id="${heading.id}">
                        ${numberPrefix}
                        <span class="toc-text">${this.escapeHTML(heading.text)}</span>
                    </a>
                    ${childrenHTML}
                </li>
            `;
        }).join('');
    }
    
    /**
     * è¦‹å‡ºã—ç•ªå·ã®å–å¾—
     */
    getHeadingNumber(heading) {
        // éšå±¤ã«å¿œã˜ãŸç•ªå·ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯
        const getNumber = (h, numbers = []) => {
            if (h.parent) {
                getNumber(h.parent, numbers);
            }
            const siblings = h.parent ? h.parent.children : this.headings.filter(h => !h.parent);
            numbers.push(siblings.indexOf(h) + 1);
            return numbers;
        };
        
        return getNumber(heading).join('.');
    }
    
    /**
     * HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
     */
    escapeHTML(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    /**
     * ç›®æ¬¡ã®æç”»
     */
    renderTOC() {
        // æ—¢å­˜ã®ç›®æ¬¡ãŒã‚ã‚Œã°å‰Šé™¤
        const existingTOC = document.querySelector('.toc-panel');
        if (existingTOC) {
            existingTOC.remove();
        }
        
        // ç›®æ¬¡ã‚’ãƒšãƒ¼ã‚¸ã«è¿½åŠ 
        document.body.appendChild(this.tocElement);
        
        // ä½ç½®ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã®èª¿æ•´
        this.adjustTOCPosition();
        this.adjustContentMargin();
    }
    
    /**
     * ç›®æ¬¡ä½ç½®ã®èª¿æ•´
     */
    adjustTOCPosition() {
        const toc = this.tocElement;
        
        switch (this.options.position) {
            case 'left':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: ${this.options.width};
                    height: 100vh;
                    z-index: 1000;
                `;
                break;
            case 'right':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    right: 0;
                    width: ${this.options.width};
                    height: 100vh;
                    z-index: 1000;
                `;
                break;
            case 'top':
                toc.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    height: 200px;
                    z-index: 1000;
                `;
                break;
        }
    }
    
    /**
     * ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒãƒ¼ã‚¸ãƒ³ã®èª¿æ•´
     */
    adjustContentMargin() {
        const content = document.querySelector('#markdown-content') || document.body;
        
        switch (this.options.position) {
            case 'left':
                content.style.marginLeft = `calc(${this.options.width} + 20px)`;
                break;
            case 'right':
                content.style.marginRight = `calc(${this.options.width} + 20px)`;
                break;
            case 'top':
                content.style.marginTop = '220px';
                break;
        }
    }
    
    /**
     * ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¹ãƒ‘ã‚¤ã®è¨­å®š
     */
    setupScrollSpy() {
        const options = {
            root: null,
            rootMargin: '-20% 0px -70% 0px',
            threshold: 0
        };
        
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.setActiveHeading(entry.target.id);
                }
            });
        }, options);
        
        // å…¨ã¦ã®è¦‹å‡ºã—è¦ç´ ã‚’ç›£è¦–
        this.headings.forEach(heading => {
            this.observer.observe(heading.element);
        });
    }
    
    /**
     * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–è¦‹å‡ºã—ã®è¨­å®š
     */
    setActiveHeading(headingId) {
        // å‰ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’å‰Šé™¤
        const prevActive = this.tocElement.querySelector('.toc-link.active');
        if (prevActive) {
            prevActive.classList.remove('active');
        }
        
        // æ–°ã—ã„ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã‚’è¨­å®š
        const newActive = this.tocElement.querySelector(`[data-heading-id="${headingId}"]`);
        if (newActive) {
            newActive.classList.add('active');
            this.activeHeading = headingId;
            
            // ç›®æ¬¡å†…ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«èª¿æ•´
            this.scrollTOCToActive(newActive);
        }
    }
    
    /**
     * ç›®æ¬¡å†…ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–é …ç›®ã¸ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
     */
    scrollTOCToActive(activeElement) {
        const tocContent = this.tocElement.querySelector('.toc-content');
        const elementTop = activeElement.offsetTop;
        const containerHeight = tocContent.clientHeight;
        const scrollTop = elementTop - containerHeight / 2;
        
        tocContent.scrollTo({
            top: scrollTop,
            behavior: 'smooth'
        });
    }
    
    /**
     * ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
     */
    bindEvents() {
        // ç›®æ¬¡ãƒªãƒ³ã‚¯ã‚¯ãƒªãƒƒã‚¯
        this.tocElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('toc-link')) {
                e.preventDefault();
                const headingId = e.target.dataset.headingId;
                this.scrollToHeading(headingId);
            }
            
            // æŠ˜ã‚ŠãŸãŸã¿ãƒœã‚¿ãƒ³
            if (e.target.classList.contains('toc-expand')) {
                this.toggleSublist(e.target);
            }
            
            // ç›®æ¬¡å…¨ä½“ã®æŠ˜ã‚ŠãŸãŸã¿
            if (e.target.classList.contains('toc-toggle')) {
                this.toggleTOC();
            }
        });
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'ArrowUp':
                        e.preventDefault();
                        this.navigateToHeading('prev');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        this.navigateToHeading('next');
                        break;
                }
            }
        });
    }
    
    /**
     * è¦‹å‡ºã—ã¸ã®ã‚¹ãƒ ãƒ¼ã‚¹ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
     */
    scrollToHeading(headingId) {
        const heading = document.getElementById(headingId);
        if (!heading) return;
        
        const offset = 20; // ãƒ˜ãƒƒãƒ€ãƒ¼ãªã©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
        const targetPosition = heading.offsetTop - offset;
        
        if (this.options.smoothScroll) {
            window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
            });
        } else {
            window.scrollTo(0, targetPosition);
        }
        
        // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹è¨­å®šï¼ˆã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼‰
        heading.focus();
    }
    
    /**
     * ã‚µãƒ–ãƒªã‚¹ãƒˆã®æŠ˜ã‚ŠãŸãŸã¿åˆ‡ã‚Šæ›¿ãˆ
     */
    toggleSublist(button) {
        const sublist = button.parentElement.querySelector('.toc-sublist');
        if (!sublist) return;
        
        const isExpanded = button.getAttribute('aria-expanded') === 'true';
        
        button.setAttribute('aria-expanded', !isExpanded);
        button.textContent = isExpanded ? 'â–¶' : 'â–¼';
        sublist.style.display = isExpanded ? 'none' : 'block';
    }
    
    /**
     * ç›®æ¬¡å…¨ä½“ã®æŠ˜ã‚ŠãŸãŸã¿åˆ‡ã‚Šæ›¿ãˆ
     */
    toggleTOC() {
        const content = this.tocElement.querySelector('.toc-content');
        const toggle = this.tocElement.querySelector('.toc-toggle');
        const isCollapsed = content.style.display === 'none';
        
        content.style.display = isCollapsed ? 'block' : 'none';
        toggle.textContent = isCollapsed ? 'âˆ’' : '+';
        
        // å¹…ã®èª¿æ•´
        if (!isCollapsed) {
            this.tocElement.style.width = '40px';
        } else {
            this.tocElement.style.width = this.options.width;
        }
    }
    
    /**
     * ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
     */
    navigateToHeading(direction) {
        if (!this.activeHeading) return;
        
        const currentIndex = this.headings.findIndex(h => h.id === this.activeHeading);
        if (currentIndex === -1) return;
        
        let targetIndex;
        if (direction === 'prev') {
            targetIndex = Math.max(0, currentIndex - 1);
        } else {
            targetIndex = Math.min(this.headings.length - 1, currentIndex + 1);
        }
        
        const targetHeading = this.headings[targetIndex];
        this.scrollToHeading(targetHeading.id);
    }
    
    /**
     * ç ´æ£„å‡¦ç†
     */
    destroy() {
        if (this.observer) {
            this.observer.disconnect();
        }
        
        if (this.tocElement) {
            this.tocElement.remove();
        }
        
        // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒãƒ¼ã‚¸ãƒ³ã®ãƒªã‚»ãƒƒãƒˆ
        const content = document.querySelector('#markdown-content') || document.body;
        content.style.marginLeft = '';
        content.style.marginRight = '';
        content.style.marginTop = '';
    }
}
```

#### 1.1.2 CSSè¨­è¨ˆ
```css
/* ç›®æ¬¡ãƒ‘ãƒãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.toc-panel {
    background: var(--toc-bg-color, #f8f9fa);
    border-right: 1px solid var(--toc-border-color, #e1e4e8);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    font-size: 14px;
    overflow-y: auto;
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
}

.toc-header {
    padding: 15px;
    border-bottom: 1px solid var(--toc-border-color, #e1e4e8);
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--toc-header-bg, #ffffff);
}

.toc-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
    color: var(--toc-text-color, #24292e);
}

.toc-toggle {
    background: none;
    border: none;
    font-size: 18px;
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
    color: var(--toc-text-color, #586069);
}

.toc-toggle:hover {
    background: var(--toc-hover-bg, #f1f3f4);
}

.toc-content {
    padding: 10px 0;
    max-height: calc(100vh - 80px);
    overflow-y: auto;
}

.toc-nav {
    padding: 0 15px;
}

.toc-list {
    list-style: none;
    margin: 0;
    padding: 0;
}

.toc-sublist {
    list-style: none;
    margin: 5px 0 0 0;
    padding-left: 20px;
}

.toc-item {
    margin: 2px 0;
    position: relative;
}

.toc-expand {
    position: absolute;
    left: -15px;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    font-size: 10px;
    cursor: pointer;
    padding: 2px;
    color: var(--toc-text-color, #586069);
}

.toc-link {
    display: flex;
    align-items: center;
    padding: 5px 8px;
    text-decoration: none;
    color: var(--toc-link-color, #0366d6);
    border-radius: 3px;
    transition: all 0.2s ease;
    line-height: 1.4;
}

.toc-link:hover {
    background: var(--toc-hover-bg, #f1f3f4);
    text-decoration: none;
}

.toc-link.active {
    background: var(--toc-active-bg, #0366d6);
    color: var(--toc-active-color, #ffffff);
    font-weight: 500;
}

.toc-number {
    margin-right: 8px;
    font-size: 12px;
    color: var(--toc-number-color, #586069);
    min-width: 20px;
}

.toc-link.active .toc-number {
    color: var(--toc-active-color, #ffffff);
}

.toc-text {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* ãƒ¬ãƒ™ãƒ«åˆ¥ã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ */
.toc-item[data-level="1"] .toc-link {
    font-weight: 600;
}

.toc-item[data-level="2"] .toc-link {
    font-size: 13px;
}

.toc-item[data-level="3"] .toc-link {
    font-size: 12px;
    opacity: 0.9;
}

.toc-item[data-level="4"],
.toc-item[data-level="5"],
.toc-item[data-level="6"] {
    font-size: 11px;
    opacity: 0.8;
}

/* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒå¯¾å¿œ */
[data-theme="dark"] .toc-panel {
    --toc-bg-color: #1a1a1a;
    --toc-border-color: #30363d;
    --toc-header-bg: #21262d;
    --toc-text-color: #c9d1d9;
    --toc-link-color: #58a6ff;
    --toc-hover-bg: #30363d;
    --toc-active-bg: #0969da;
    --toc-active-color: #ffffff;
    --toc-number-color: #8b949e;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 768px) {
    .toc-panel {
        transform: translateX(-100%);
        transition: transform 0.3s ease;
    }
    
    .toc-panel.mobile-open {
        transform: translateX(0);
    }
    
    .toc-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        display: none;
    }
    
    .toc-overlay.active {
        display: block;
    }
}
```

### 1.2 ãƒ†ãƒ¼ãƒã‚·ã‚¹ãƒ†ãƒ è©³ç´°è¨­è¨ˆ

#### 1.2.1 ThemeManagerã‚¯ãƒ©ã‚¹
```javascript
/**
 * ãƒ†ãƒ¼ãƒç®¡ç†ã‚¯ãƒ©ã‚¹
 */
class ThemeManager {
    constructor() {
        this.themes = new Map();
        this.currentTheme = 'light';
        this.customCSS = '';
        this.systemThemeQuery = null;
        this.observers = new Set();
        
        this.init();
    }
    
    /**
     * åˆæœŸåŒ–å‡¦ç†
     */
    async init() {
        await this.loadSettings();
        this.registerDefaultThemes();
        this.setupSystemThemeDetection();
        this.applyTheme(this.currentTheme);
    }
    
    /**
     * è¨­å®šã®èª­ã¿è¾¼ã¿
     */
    async loadSettings() {
        try {
            const result = await chrome.storage.sync.get(['theme', 'customCSS']);
            this.currentTheme = result.theme || 'light';
            this.customCSS = result.customCSS || '';
        } catch (error) {
            console.warn('Failed to load theme settings:', error);
        }
    }
    
    /**
     * ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ¼ãƒã®ç™»éŒ²
     */
    registerDefaultThemes() {
        // ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒ
        this.registerTheme('light', {
            name: 'Light',
            variables: {
                '--bg-color': '#ffffff',
                '--text-color': '#24292e',
                '--heading-color': '#1f2328',
                '--link-color': '#0969da',
                '--border-color': '#d1d9e0',
                '--code-bg': '#f6f8fa',
                '--blockquote-border': '#d1d9e0',
                '--table-border': '#d1d9e0',
                '--table-header-bg': '#f6f8fa'
            },
            mermaidTheme: 'default'
        });
        
        // ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒ
        this.registerTheme('dark', {
            name: 'Dark',
            variables: {
                '--bg-color': '#0d1117',
                '--text-color': '#e6edf3',
                '--heading-color': '#f0f6fc',
                '--link-color': '#2f81f7',
                '--border-color': '#30363d',
                '--code-bg': '#161b22',
                '--blockquote-border': '#30363d',
                '--table-border': '#30363d',
                '--table-header-bg': '#161b22'
            },
            mermaidTheme: 'dark'
        });
        

    }
    
    /**
     * ãƒ†ãƒ¼ãƒã®ç™»éŒ²
     */
    registerTheme(name, config) {
        this.themes.set(name, {
            name: config.name || name,
            variables: config.variables || {},
            mermaidTheme: config.mermaidTheme || 'default',
            customCSS: config.customCSS || '',
            ...config
        });
    }
    
    /**
     * ã‚·ã‚¹ãƒ†ãƒ ãƒ†ãƒ¼ãƒæ¤œå‡ºã®è¨­å®š
     */
    setupSystemThemeDetection() {
        this.systemThemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
        this.systemThemeQuery.addEventListener('change', (e) => {
            if (this.currentTheme === 'auto') {
                this.applyTheme('auto');
            }
        });
    }
    
    /**
     * ãƒ†ãƒ¼ãƒã®é©ç”¨
     */
    async applyTheme(themeName) {
        let actualTheme = themeName;
        
        // è‡ªå‹•ãƒ†ãƒ¼ãƒã®å ´åˆã¯ã‚·ã‚¹ãƒ†ãƒ è¨­å®šã«å¾“ã†
        if (themeName === 'auto') {
            actualTheme = this.detectSystemTheme();
        }
        
        const theme = this.themes.get(actualTheme);
        if (!theme) {
            console.warn(`Theme "${actualTheme}" not found`);
            return;
        }
        
        // CSSå¤‰æ•°ã®é©ç”¨
        this.applyCSSVariables(theme.variables);
        
        // ã‚«ã‚¹ã‚¿ãƒ CSSã®é©ç”¨
        this.applyCustomCSS(theme.customCSS);
        
        // Mermaidãƒ†ãƒ¼ãƒã®é©ç”¨
        await this.applyMermaidTheme(theme.mermaidTheme);
        
        // data-themeå±æ€§ã®è¨­å®š
        document.documentElement.setAttribute('data-theme', actualTheme);
        
        // ç¾åœ¨ã®ãƒ†ãƒ¼ãƒã‚’ä¿å­˜
        this.currentTheme = themeName;
        await this.saveSettings();
        
        // ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã«é€šçŸ¥
        this.notifyObservers('themeChanged', { theme: actualTheme, config: theme });
    }
    
    /**
     * CSSå¤‰æ•°ã®é©ç”¨
     */
    applyCSSVariables(variables) {
        const root = document.documentElement;
        
        Object.entries(variables).forEach(([property, value]) => {
            root.style.setProperty(property, value);
        });
    }
    
    /**
     * ã‚«ã‚¹ã‚¿ãƒ CSSã®é©ç”¨
     */
    applyCustomCSS(css) {
        // æ—¢å­˜ã®ã‚«ã‚¹ã‚¿ãƒ CSSã‚’å‰Šé™¤
        const existingStyle = document.getElementById('theme-custom-css');
        if (existingStyle) {
            existingStyle.remove();
        }
        
        // æ–°ã—ã„ã‚«ã‚¹ã‚¿ãƒ CSSã‚’è¿½åŠ 
        if (css) {
            const style = document.createElement('style');
            style.id = 'theme-custom-css';
            style.textContent = css;
            document.head.appendChild(style);
        }
    }
    
    /**
     * Mermaidãƒ†ãƒ¼ãƒã®é©ç”¨
     */
    async applyMermaidTheme(mermaidTheme) {
        if (typeof mermaid !== 'undefined') {
            // Mermaidã®å†åˆæœŸåŒ–
            mermaid.initialize({
                startOnLoad: false,
                theme: mermaidTheme,
                securityLevel: 'loose',
                flowchart: {
                    useMaxWidth: true,
                    htmlLabels: true
                }
            });
            
            // æ—¢å­˜ã®Mermaidå›³ã‚’å†æç”»
            await this.rerenderMermaidDiagrams();
        }
    }
    
    /**
     * Mermaidå›³ã®å†æç”»
     */
    async rerenderMermaidDiagrams() {
        const mermaidElements = document.querySelectorAll('.mermaid');
        
        for (const element of mermaidElements) {
            try {
                // å…ƒã®ã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆdataå±æ€§ã«ä¿å­˜ã•ã‚Œã¦ã„ã‚‹æƒ³å®šï¼‰
                const originalCode = element.dataset.mermaidCode || element.textContent;
                
                if (originalCode) {
                    const { svg } = await mermaid.render(`mermaid-${Date.now()}`, originalCode);
                    element.innerHTML = svg;
                }
            } catch (error) {
                console.error('Failed to re-render mermaid diagram:', error);
            }
        }
    }
    
    /**
     * ã‚·ã‚¹ãƒ†ãƒ ãƒ†ãƒ¼ãƒã®æ¤œå‡º
     */
    detectSystemTheme() {
        return this.systemThemeQuery?.matches ? 'dark' : 'light';
    }
    
    /**
     * åˆ©ç”¨å¯èƒ½ãªãƒ†ãƒ¼ãƒä¸€è¦§ã®å–å¾—
     */
    getAvailableThemes() {
        return Array.from(this.themes.entries()).map(([key, theme]) => ({
            key,
            name: theme.name,
            preview: this.generateThemePreview(theme)
        }));
    }
    
    /**
     * ãƒ†ãƒ¼ãƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ç”Ÿæˆ
     */
    generateThemePreview(theme) {
        return {
            backgroundColor: theme.variables['--bg-color'],
            textColor: theme.variables['--text-color'],
            headingColor: theme.variables['--heading-color'],
            linkColor: theme.variables['--link-color']
        };
    }
    
    /**
     * ã‚«ã‚¹ã‚¿ãƒ CSSã®è¨­å®š
     */
    async setCustomCSS(css) {
        this.customCSS = css;
        this.applyCustomCSS(css);
        await this.saveSettings();
    }
    
    /**
     * è¨­å®šã®ä¿å­˜
     */
    async saveSettings() {
        try {
            await chrome.storage.sync.set({
                theme: this.currentTheme,
                customCSS: this.customCSS
            });
        } catch (error) {
            console.error('Failed to save theme settings:', error);
        }
    }
    
    /**
     * ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã®è¿½åŠ 
     */
    addObserver(callback) {
        this.observers.add(callback);
    }
    
    /**
     * ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã®å‰Šé™¤
     */
    removeObserver(callback) {
        this.observers.delete(callback);
    }
    
    /**
     * ã‚ªãƒ–ã‚¶ãƒ¼ãƒãƒ¼ã¸ã®é€šçŸ¥
     */
    notifyObservers(event, data) {
        this.observers.forEach(callback => {
            try {
                callback(event, data);
            } catch (error) {
                console.error('Observer callback error:', error);
            }
        });
    }
    
    /**
     * ç ´æ£„å‡¦ç†
     */
    destroy() {
        if (this.systemThemeQuery) {
            this.systemThemeQuery.removeEventListener('change', this.handleSystemThemeChange);
        }
        
        this.observers.clear();
    }
}
```

#### 1.2.2 ãƒ†ãƒ¼ãƒã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼UI
```javascript
/**
 * ãƒ†ãƒ¼ãƒé¸æŠUIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
 */
class ThemeSelector {
    constructor(container, themeManager) {
        this.container = container;
        this.themeManager = themeManager;
        this.isOpen = false;
        
        this.render();
        this.bindEvents();
    }
    
    render() {
        const themes = this.themeManager.getAvailableThemes();
        const currentTheme = this.themeManager.currentTheme;
        
        this.container.innerHTML = `
            <div class="theme-selector">
                <button class="theme-selector-button" title="ãƒ†ãƒ¼ãƒã‚’é¸æŠ">
                    ğŸ¨ <span class="theme-name">${this.getThemeName(currentTheme)}</span>
                </button>
                <div class="theme-dropdown" style="display: none;">
                    <div class="theme-options">
                        ${themes.map(theme => `
                            <div class="theme-option ${theme.key === currentTheme ? 'active' : ''}" 
                                 data-theme="${theme.key}">
                                <div class="theme-preview" style="
                                    background: ${theme.preview.backgroundColor};
                                    color: ${theme.preview.textColor};
                                    border: 1px solid ${theme.preview.linkColor};
                                ">
                                    <div class="preview-text">Aa</div>
                                </div>
                                <span class="theme-label">${theme.name}</span>
                            </div>
                        `).join('')}
                    </div>
                    <div class="theme-actions">
                        <button class="custom-css-button">ã‚«ã‚¹ã‚¿ãƒ CSS</button>
                        <button class="auto-theme-button ${currentTheme === 'auto' ? 'active' : ''}">
                            è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ
                        </button>
                    </div>
                </div>
            </div>
        `;
    }
    
    getThemeName(themeKey) {
        if (themeKey === 'auto') return 'è‡ªå‹•';
        const theme = this.themeManager.themes.get(themeKey);
        return theme ? theme.name : themeKey;
    }
    
    bindEvents() {
        const button = this.container.querySelector('.theme-selector-button');
        const dropdown = this.container.querySelector('.theme-dropdown');
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®é–‹é–‰
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDropdown();
        });
        
        // ãƒ†ãƒ¼ãƒé¸æŠ
        dropdown.addEventListener('click', (e) => {
            if (e.target.closest('.theme-option')) {
                const themeKey = e.target.closest('.theme-option').dataset.theme;
                this.selectTheme(themeKey);
            }
            
            if (e.target.classList.contains('auto-theme-button')) {
                this.toggleAutoTheme();
            }
            
            if (e.target.classList.contains('custom-css-button')) {
                this.openCustomCSSEditor();
            }
        });
        
        // å¤–éƒ¨ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        document.addEventListener('click', () => {
            this.closeDropdown();
        });
    }
    
    toggleDropdown() {
        this.isOpen = !this.isOpen;
        const dropdown = this.container.querySelector('.theme-dropdown');
        dropdown.style.display = this.isOpen ? 'block' : 'none';
    }
    
    closeDropdown() {
        this.isOpen = false;
        const dropdown = this.container.querySelector('.theme-dropdown');
        dropdown.style.display = 'none';
    }
    
    async selectTheme(themeKey) {
        await this.themeManager.applyTheme(themeKey);
        this.updateUI();
        this.closeDropdown();
    }
    
    toggleAutoTheme() {
        const currentTheme = this.themeManager.currentTheme;
        const newTheme = currentTheme === 'auto' ? 'light' : 'auto';
        this.selectTheme(newTheme);
    }
    
    updateUI() {
        const currentTheme = this.themeManager.currentTheme;
        
        // ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æ›´æ–°
        const themeName = this.container.querySelector('.theme-name');
        themeName.textContent = this.getThemeName(currentTheme);
        
        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®æ›´æ–°
        this.container.querySelectorAll('.theme-option').forEach(option => {
            option.classList.toggle('active', option.dataset.theme === currentTheme);
        });
        
        // è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
        const autoButton = this.container.querySelector('.auto-theme-button');
        autoButton.classList.toggle('active', currentTheme === 'auto');
    }
    
    openCustomCSSEditor() {
        // ã‚«ã‚¹ã‚¿ãƒ CSSã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’é–‹ãï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ã¾ãŸã¯åˆ¥ãƒšãƒ¼ã‚¸ï¼‰
        const modal = this.createCustomCSSModal();
        document.body.appendChild(modal);
    }
    
    createCustomCSSModal() {
        const modal = document.createElement('div');
        modal.className = 'custom-css-modal';
        modal.innerHTML = `
            <div class="modal-overlay">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>ã‚«ã‚¹ã‚¿ãƒ CSS</h3>
                        <button class="modal-close">Ã—</button>
                    </div>
                    <div class="modal-body">
                        <textarea class="custom-css-editor" placeholder="/* ã‚«ã‚¹ã‚¿ãƒ CSSã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ */\n\nbody {\n    /* ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨˜è¿° */\n}">${this.themeManager.customCSS}</textarea>
                    </div>
                    <div class="modal-footer">
                        <button class="css-apply-button">é©ç”¨</button>
                        <button class="css-reset-button">ãƒªã‚»ãƒƒãƒˆ</button>
                        <button class="css-cancel-button">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                    </div>
                </div>
            </div>
        `;
        
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚¤ãƒ™ãƒ³ãƒˆ
        modal.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay') || 
                e.target.classList.contains('modal-close') ||
                e.target.classList.contains('css-cancel-button')) {
                modal.remove();
            }
            
            if (e.target.classList.contains('css-apply-button')) {
                const css = modal.querySelector('.custom-css-editor').value;
                this.themeManager.setCustomCSS(css);
                modal.remove();
            }
            
            if (e.target.classList.contains('css-reset-button')) {
                modal.querySelector('.custom-css-editor').value = '';
            }
        });
        
        return modal;
    }
}
```

### 1.3 Markdownç·¨é›†æ©Ÿèƒ½è©³ç´°è¨­è¨ˆ

#### 1.3.1 MarkdownEditorã‚¯ãƒ©ã‚¹
```javascript
/**
 * Markdownç·¨é›†æ©Ÿèƒ½ã‚¯ãƒ©ã‚¹
 */
class MarkdownEditor {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            autoSave: false,
            saveInterval: 30000,
            backupEnabled: true,
            confirmBeforeSave: true,
            ...options
        };
        
        this.isEditing = false;
        this.originalContent = '';
        this.currentContent = '';
        this.isDirty = false;
        this.autoSaveTimer = null;
        this.editorElement = null;
        this.previewElement = null;
        
        this.init();
    }
    
    /**
     * åˆæœŸåŒ–å‡¦ç†
     */
    init() {
        this.createEditorUI();
        this.bindEvents();
        this.setupAutoSave();
    }
    
    /**
     * ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼UIã®ä½œæˆ
     */
    createEditorUI() {
        this.editorElement = document.createElement('div');
        this.editorElement.className = 'markdown-editor';
        this.editorElement.innerHTML = `
            <div class="editor-toolbar">
                <button class="editor-btn" data-action="save" title="ä¿å­˜">ğŸ’¾</button>
                <button class="editor-btn" data-action="save-as" title="åˆ¥åä¿å­˜">ğŸ“„</button>
                <button class="editor-btn" data-action="preview" title="ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼">ğŸ‘ï¸</button>
                <button class="editor-btn" data-action="close" title="é–‰ã˜ã‚‹">âœ•</button>
                <span class="editor-status"></span>
            </div>
            <div class="editor-content">
                <div class="editor-pane">
                    <textarea class="editor-textarea" placeholder="Markdownã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>
                </div>
                <div class="preview-pane" style="display: none;">
                    <div class="preview-content"></div>
                </div>
            </div>
        `;
        
        this.container.appendChild(this.editorElement);
        this.textarea = this.editorElement.querySelector('.editor-textarea');
        this.previewElement = this.editorElement.querySelector('.preview-content');
    }
    
    /**
     * ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã‚’é–‹å§‹
     */
    startEditing(content = '') {
        this.originalContent = content;
        this.currentContent = content;
        this.textarea.value = content;
        this.isEditing = true;
        this.isDirty = false;
        
        this.editorElement.style.display = 'block';
        this.textarea.focus();
        
        this.updateStatus('ç·¨é›†ä¸­');
    }
    
    /**
     * ä¿å­˜å‡¦ç†
     */
    async save(saveAs = false) {
        try {
            const content = this.textarea.value;
            const fileManager = window.fileManager;
            
            if (!fileManager) {
                throw new Error('FileManager not available');
            }
            
            let result;
            if (saveAs) {
                result = await fileManager.saveAs(content);
            } else {
                result = await fileManager.save(content);
            }
            
            if (result.success) {
                this.originalContent = content;
                this.currentContent = content;
                this.isDirty = false;
                this.updateStatus('ä¿å­˜å®Œäº†');
                
                // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
                if (this.options.backupEnabled) {
                    await fileManager.createBackup(content);
                }
            } else {
                throw new Error(result.error || 'ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
            
        } catch (error) {
            console.error('Save error:', error);
            this.updateStatus('ä¿å­˜ã‚¨ãƒ©ãƒ¼: ' + error.message);
        }
    }
    
    /**
     * ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
     */
    bindEvents() {
        // ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ãƒœã‚¿ãƒ³
        this.editorElement.addEventListener('click', (e) => {
            if (e.target.classList.contains('editor-btn')) {
                const action = e.target.dataset.action;
                this.handleToolbarAction(action);
            }
        });
        
        // ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›´ç›£è¦–
        this.textarea.addEventListener('input', () => {
            this.currentContent = this.textarea.value;
            this.isDirty = this.currentContent !== this.originalContent;
            this.updateStatus(this.isDirty ? 'æœªä¿å­˜' : 'ä¿å­˜æ¸ˆã¿');
        });
    }
    
    /**
     * ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†
     */
    async handleToolbarAction(action) {
        switch (action) {
            case 'save':
                await this.save();
                break;
            case 'save-as':
                await this.save(true);
                break;
            case 'close':
                this.stopEditing();
                break;
        }
    }
    
    /**
     * ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
     */
    updateStatus(message) {
        const statusElement = this.editorElement.querySelector('.editor-status');
        statusElement.textContent = message;
    }
}
```

---

**ä½œæˆæ—¥**: 2025å¹´1æœˆ28æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆè€…**: Kiro AI Assistant
##
# 1.5 ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†æ©Ÿèƒ½è©³ç´°è¨­è¨ˆ

#### 1.5.1 FileManagerã‚¯ãƒ©ã‚¹
```javascript
/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
 */
class FileManager {
    constructor(options = {}) {
        this.options = {
            defaultSaveMode: 'overwrite',
            confirmBeforeSave: true,
            backupEnabled: true,
            backupCount: 5,
            ...options
        };
        
        this.currentFilePath = null;
        this.backups = [];
        
        this.init();
    }
    
    /**
     * åˆæœŸåŒ–å‡¦ç†
     */
    init() {
        this.loadBackups();
    }
    
    /**
     * ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜ï¼ˆä¸Šæ›¸ãï¼‰
     */
    async save(content) {
        try {
            if (!this.currentFilePath) {
                return await this.saveAs(content);
            }
            
            if (this.options.confirmBeforeSave) {
                if (!confirm('ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãä¿å­˜ã—ã¾ã™ã‹ï¼Ÿ')) {
                    return { success: false, cancelled: true };
                }
            }
            
            // File System Access API ã‚’ä½¿ç”¨ï¼ˆChrome 86+ï¼‰
            if ('showSaveFilePicker' in window) {
                const fileHandle = await this.getFileHandle();
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                
                return { success: true, filePath: fileHandle.name };
            } else {
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨ã—ã¦ä¿å­˜
                return this.downloadFile(content, this.currentFilePath);
            }
            
        } catch (error) {
            console.error('Save error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * åˆ¥åä¿å­˜
     */
    async saveAs(content) {
        try {
            let fileName = 'document.md';
            
            // File System Access API ã‚’ä½¿ç”¨
            if ('showSaveFilePicker' in window) {
                const fileHandle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{
                        description: 'Markdown files',
                        accept: { 'text/markdown': ['.md', '.markdown'] }
                    }]
                });
                
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                
                this.currentFilePath = fileHandle.name;
                return { success: true, filePath: fileHandle.name };
                
            } else {
                // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨ã—ã¦ä¿å­˜
                fileName = prompt('ãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:', fileName);
                if (!fileName) {
                    return { success: false, cancelled: true };
                }
                
                return this.downloadFile(content, fileName);
            }
            
        } catch (error) {
            console.error('SaveAs error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã¨ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
     */
    downloadFile(content, fileName) {
        try {
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            
            return { success: true, filePath: fileName };
            
        } catch (error) {
            console.error('Download error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
     */
    async createBackup(content) {
        if (!this.options.backupEnabled) return;
        
        try {
            const backup = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                content: content,
                filePath: this.currentFilePath
            };
            
            this.backups.unshift(backup);
            
            // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ•°ã®åˆ¶é™
            if (this.backups.length > this.options.backupCount) {
                this.backups = this.backups.slice(0, this.options.backupCount);
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
            await this.saveBackups();
            
            return { success: true, backupId: backup.id };
            
        } catch (error) {
            console.error('Backup error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¾©å…ƒ
     */
    async restoreBackup(backupId) {
        try {
            const backup = this.backups.find(b => b.id === backupId);
            if (!backup) {
                throw new Error('ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
            }
            
            if (confirm('ã“ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚’å¾©å…ƒã—ã¾ã™ã‹ï¼Ÿç¾åœ¨ã®å†…å®¹ã¯å¤±ã‚ã‚Œã¾ã™ã€‚')) {
                return { success: true, content: backup.content };
            }
            
            return { success: false, cancelled: true };
            
        } catch (error) {
            console.error('Restore error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * Mermaidã‚³ãƒ¼ãƒ‰ã®æ›´æ–°
     */
    async updateMermaidCode(mermaidElement, newCode, saveAs = false) {
        try {
            // ç¾åœ¨ã®Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
            const markdownContent = this.getCurrentMarkdownContent();
            
            // Mermaidã‚³ãƒ¼ãƒ‰ã‚’ç½®æ›
            const updatedContent = this.replaceMermaidCode(markdownContent, mermaidElement, newCode);
            
            // ä¿å­˜
            let result;
            if (saveAs) {
                result = await this.saveAs(updatedContent);
            } else {
                result = await this.save(updatedContent);
            }
            
            return result;
            
        } catch (error) {
            console.error('Update Mermaid error:', error);
            return { success: false, error: error.message };
        }
    }
    
    /**
     * ç¾åœ¨ã®Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
     */
    getCurrentMarkdownContent() {
        // å®Ÿè£…: ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹Markdownã®å…ƒã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’å–å¾—
        // ã“ã‚Œã¯å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’ä¿æŒã™ã‚‹ä»•çµ„ã¿ãŒå¿…è¦
        return document.body.dataset.originalMarkdown || '';
    }
    
    /**
     * Mermaidã‚³ãƒ¼ãƒ‰ã®ç½®æ›
     */
    replaceMermaidCode(markdownContent, mermaidElement, newCode) {
        // å®Ÿè£…: Markdownã‚³ãƒ³ãƒ†ãƒ³ãƒ„å†…ã®å¯¾å¿œã™ã‚‹Mermaidãƒ–ãƒ­ãƒƒã‚¯ã‚’æ–°ã—ã„ã‚³ãƒ¼ãƒ‰ã§ç½®æ›
        const mermaidId = mermaidElement.id || mermaidElement.dataset.mermaidId;
        
        // ç°¡å˜ãªå®Ÿè£…ä¾‹ï¼ˆå®Ÿéš›ã¯ã‚ˆã‚Šå …ç‰¢ãªå®Ÿè£…ãŒå¿…è¦ï¼‰
        const mermaidRegex = /```mermaid\n([\s\S]*?)\n```/g;
        let matchCount = 0;
        
        return markdownContent.replace(mermaidRegex, (match, code) => {
            matchCount++;
            if (matchCount === parseInt(mermaidId?.replace('mermaid-', '') || '1')) {
                return `\`\`\`mermaid\n${newCode}\n\`\`\``;
            }
            return match;
        });
    }
    
    /**
     * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®ä¿å­˜
     */
    async saveBackups() {
        try {
            const backupsData = JSON.stringify(this.backups);
            localStorage.setItem('markdown-viewer-backups', backupsData);
        } catch (error) {
            console.error('Save backups error:', error);
        }
    }
    
    /**
     * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã®èª­ã¿è¾¼ã¿
     */
    loadBackups() {
        try {
            const backupsData = localStorage.getItem('markdown-viewer-backups');
            if (backupsData) {
                this.backups = JSON.parse(backupsData);
            }
        } catch (error) {
            console.error('Load backups error:', error);
            this.backups = [];
        }
    }
    
    /**
     * ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¸€è¦§ã®å–å¾—
     */
    getBackups() {
        return this.backups.map(backup => ({
            id: backup.id,
            timestamp: backup.timestamp,
            filePath: backup.filePath,
            preview: backup.content.substring(0, 100) + '...'
        }));
    }
    
    /**
     * ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
     */
    async getFileHandle() {
        // å®Ÿè£…: ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
        // File System Access API ã®å®Ÿè£…è©³ç´°
        return this.currentFileHandle;
    }
    
    /**
     * ç ´æ£„å‡¦ç†
     */
    destroy() {
        this.saveBackups();
    }
}
```

#### 1.5.2 CSSè¨­è¨ˆï¼ˆç·¨é›†æ©Ÿèƒ½ç”¨ï¼‰
```css
/* Markdown ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ */
.markdown-editor {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--bg-color, #ffffff);
    z-index: 2000;
    display: none;
}

.editor-toolbar {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    background: var(--toolbar-bg, #f6f8fa);
    border-bottom: 1px solid var(--border-color, #d1d9e0);
    gap: 10px;
}

.editor-btn {
    background: var(--button-bg, #ffffff);
    border: 1px solid var(--border-color, #d1d9e0);
    border-radius: 6px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.editor-btn:hover {
    background: var(--button-hover-bg, #f3f4f6);
}

.editor-status {
    margin-left: auto;
    font-size: 12px;
    color: var(--text-secondary, #656d76);
}

.editor-content {
    display: flex;
    height: calc(100vh - 60px);
}

.editor-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.editor-textarea {
    flex: 1;
    border: none;
    outline: none;
    padding: 20px;
    font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    background: var(--bg-color, #ffffff);
    color: var(--text-color, #24292e);
}

.preview-pane {
    flex: 1;
    border-left: 1px solid var(--border-color, #d1d9e0);
    overflow-y: auto;
}

.preview-content {
    padding: 20px;
}

/* Mermaid ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ */
.mermaid-editor-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    z-index: 3000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.mermaid-editor-modal {
    background: var(--bg-color, #ffffff);
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 90vw;
    height: 80vh;
    max-width: 1200px;
    display: flex;
    flex-direction: column;
}

.mermaid-editor-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 15px 20px;
    border-bottom: 1px solid var(--border-color, #d1d9e0);
}

.mermaid-editor-header h3 {
    margin: 0;
    font-size: 18px;
    color: var(--text-color, #24292e);
}

.mermaid-editor-close {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
    color: var(--text-secondary, #656d76);
}

.mermaid-editor-close:hover {
    background: var(--button-hover-bg, #f3f4f6);
}

.mermaid-editor-content {
    flex: 1;
    display: flex;
    min-height: 0;
}

.mermaid-editor-pane {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.mermaid-code-editor {
    flex: 1;
    border: none;
    outline: none;
    padding: 20px;
    font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
    font-size: 14px;
    line-height: 1.6;
    resize: none;
    background: var(--code-bg, #f6f8fa);
    color: var(--text-color, #24292e);
}

.mermaid-preview-pane {
    flex: 1;
    border-left: 1px solid var(--border-color, #d1d9e0);
    overflow: auto;
    background: var(--bg-color, #ffffff);
}

.mermaid-preview {
    padding: 20px;
    text-align: center;
}

.mermaid-error {
    color: #d73a49;
    background: #ffeef0;
    padding: 15px;
    border-radius: 6px;
    border: 1px solid #fdb8c0;
}

.mermaid-editor-footer {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 15px 20px;
    border-top: 1px solid var(--border-color, #d1d9e0);
    background: var(--toolbar-bg, #f6f8fa);
}

.mermaid-save-btn,
.mermaid-save-as-btn,
.mermaid-cancel-btn {
    background: var(--button-bg, #ffffff);
    border: 1px solid var(--border-color, #d1d9e0);
    border-radius: 6px;
    padding: 8px 16px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

.mermaid-save-btn {
    background: var(--primary-color, #0969da);
    color: white;
    border-color: var(--primary-color, #0969da);
}

.mermaid-save-btn:hover {
    background: var(--primary-hover, #0860ca);
}

.mermaid-editor-status {
    margin-left: auto;
    font-size: 12px;
    color: var(--text-secondary, #656d76);
}

/* ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒå¯¾å¿œ */
[data-theme="dark"] {
    --toolbar-bg: #21262d;
    --button-bg: #21262d;
    --button-hover-bg: #30363d;
    --primary-color: #2f81f7;
    --primary-hover: #1f6feb;
    --text-secondary: #8b949e;
}
```

---

**ä½œæˆæ—¥**: 2025å¹´1æœˆ28æ—¥  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 1.0  
**ä½œæˆè€…**: Kiro AI Assistant